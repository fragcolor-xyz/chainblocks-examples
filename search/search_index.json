{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tutorials","title":"Tutorials","text":"<p>These tutorials will help you to get familiar with programming in Shards and give you a glimpse of what you can create with it. Note that these are simplified examples to better convey basic concepts and ideas - you can definitely achieve much more beyond what these tutorials provide! </p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Ensure that your development environment is set up and that you have Shards downloaded before attempting these tutorials.</p> Snake Game Yes-No Game Glod Game <p>More to come. Stay tuned!</p> <p> </p> <p>Built on Jun 27, 2023 at 19:01:23 from commit 04c4926.</p>"},{"location":"glod-game/","title":"Glod Game Tutorial","text":"<p>Hello there! In this tutorial, we will be making a 2D point collection game using Shards.</p> <p>This tutorial assumes that you have a basic understanding of Shards. In order to run the code examples used here, you are required to have Shards installed. </p> <p>For more information, check out the following links:</p> <ol> <li> <p>The Basics of Shards</p> </li> <li> <p>Install Shards</p> </li> </ol>"},{"location":"glod-game/#key-concepts","title":"Key Concepts","text":"<p>Here are the key concepts that we will be covering in this tutorial:</p> <ol> <li> <p>How to draw a character image on the screen</p> </li> <li> <p>How to animate a character using an image array</p> </li> <li> <p>How to move a character using button inputs</p> </li> <li> <p>Controlling flow, using Step</p> </li> <li> <p>Setting up a scoring system</p> </li> </ol> <p>You can either follow the step-by-step guide or jump directly to the full game.</p> <ul> <li> <p>Introduction</p> </li> <li> <p>Step by step</p> </li> <li> <p>Full game</p> </li> </ul> <p> </p>"},{"location":"glod-game/introduction/","title":"Introduction","text":""},{"location":"glod-game/introduction/#gameplay","title":"Gameplay","text":"<p>In this game, players will enter the world of Glod - a charming and lovable character with a passion for collecting coins. Players have 60 seconds to collect as many coins as they can while dodging spiked balls that fall from the sky.</p> <p> </p>"},{"location":"glod-game/full-game/","title":"Full game","text":"EDN glodgame.edn<pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n;;------------ Scoring Limits ----------\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged\n\n60 &gt;= .timer\n0 &gt;= .gameOver)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\ntrue &gt; .score-effect-play\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\ntrue &gt; .damage-effect-play\nfalse &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n;; --------------- Damaged Effect ----------------\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play\n\n(LoadTexture \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n.damage-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.damage-effect-array-index (Math.Add 1)\n&gt; .damage-effect-array-index\n(When :Predicate (IsMore .damage-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .damage-effect-array-index\nfalse &gt; .damage-effect-play))))\n\n(Pause .damage-effect-animation-speed))\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n.score-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When :Predicate (IsMore .score-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n\n\n(Pause .score-effect-animation-speed))\n\n;; -------- Timer -----------\n(defloop timer-countdown\n.gameOver\n(When :Predicate (-&gt;\n(Is 0)\n(And)\n.timer (IsMore 0))\n:Action (-&gt;\n.timer (Math.Subtract 1)\n&gt; .timer))\n\n(Pause 1.0))\n\n;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n.timer\n(When :Predicate (Is 0)\n:Action (-&gt;\n1 &gt; .gameOver)))\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;; -------- Game_Over_UI -------------\n(defloop gameOver-ui\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.Center\n:Contents (-&gt;\nstyle (UI.Style)\n\"Score\" (UI.Label)\n.score (ToString) (UI.Label)\n(UI.Button :Label \"Restart\"\n:Action (-&gt;\n0 &gt; .gameOver\n60 &gt; .timer\n0 &gt; .score\n(float2 0 0) &gt; .character-position)))))\n\n(defloop mainGame-ui\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.bg-image (UI.Image :Scale (float2 0.7))))\n\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; ---------- Coins -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n;; ------------SpikeBalls ------------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n;; --------------- UI Score --------------\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))\n\n;; --------------- UI Timer --------------\n(UI.Area :Position (float2 40 20)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nstyle (UI.Style)\n.timer (ToString) (UI.Label))))\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs)\n(initialize-effects))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n(Step damage-effect-animation-logic)\n\n(Step timer-countdown)\n(gameOver-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n.gameOver\n(Match [0 (-&gt; (Step mainGame-ui))\n1 (-&gt; (Step gameOver-ui))]\n:Passthrough false)))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/","title":"Steps","text":"<ul> <li>Step 1 - Drawing Glod's Image with UI</li> <li>Step 2 - Changing Glod's Image with Button Inputs</li> <li>Step 3 - Animating Glod with Image Arrays</li> <li>Step 4 - Moving Glod with Button Inputs</li> <li>Step 5 - Dropping Coins and Scoring Points</li> <li>Step 6 - Making the Game Harder</li> <li>Step 7 - Polishing the Game</li> </ul>"},{"location":"glod-game/steps/step-1/","title":"Step 1","text":""},{"location":"glod-game/steps/step-1/#drawing-a-character-image-using-ui-overview","title":"Drawing a Character Image using UI - Overview","text":"<p>Let's start things off nice and easy. In this step, we will simply be:</p> <ol> <li> <p>Creating the <code>GFX.Window</code>.</p> </li> <li> <p>Drawing our Character Image in the <code>GFX.Window</code>.</p> </li> <li> <p>Scheduling our Wire on the Mesh and running it.</p> </li> </ol>"},{"location":"glod-game/steps/step-1/#step-11-readying-the-image","title":"Step 1.1: Readying the Image","text":"<p>Before we can draw our character on the screen, we will need the image file. Any image file will do. If you don't have one, say hello to Glod! Right-click and save the image of Glod below. </p> <p></p> <ol> <li>Create a folder named \"GlodImages\" in the same location as where your script will be located.</li> <li>Add your image into the newly created folder.</li> <li>Name your image \"Character1.png\".</li> </ol> <p>With our image file readied, we can start!</p>"},{"location":"glod-game/steps/step-1/#step-12-initializing-our-variables","title":"Step 1.2: Initializing our Variables","text":"<p>First, create the variable <code>.character-image</code> to assign our Image file to. Use the shard <code>LoadImage</code> to load the image into the variable. Set your image's location as its parameter.</p> <p>We will wrap this line of code in a <code>defshards</code> shard. This shard will be called at the start of our code, where we will be initializing all our variables. </p> What is Initializing? <p>Initializing is the assigning of an initial value to a variable when it is declared.</p> Initialization Code <pre><code>(defshards initialize-character []\n(LoadImage \"GlodImages/Character1.png\") = .character-image)\n</code></pre>"},{"location":"glod-game/steps/step-1/#step-13-creating-the-main-looped-wire","title":"Step 1.3: Creating the main Looped Wire","text":"<p>Following that, we will create the main Looped Wire which will be scheduled on the Mesh. The <code>initialize-character</code> shard that we have just created will be called at the start of this Looped Wire. It will be wrapped in a <code>Setup</code> shard.</p> The Setup shard <p>The <code>Setup</code> shard ensures that every line of code called within it will only happen once. By placing the <code>initialize-character</code> shard within a <code>Setup</code> shard, we ensure that it is only called once despite being placed in a <code>defloop</code>.</p> <p>We want to initialize variables once only as we do not want our program to continuously create a new instance of the same variable every time the Wire loops. We only need one instance of our variables which will be reused.</p> Main Looped Wire <pre><code>(defshards initialize-character []\n(LoadImage \"GlodImages/Character1.png\") = .character-image) ;; (1)\n\n(defloop main-wire\n(Setup\n(initialize-character)))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <ol> <li><code>.character-image</code> is the variable that contains our image.</li> </ol>"},{"location":"glod-game/steps/step-1/#step-14-creating-the-window","title":"Step 1.4: Creating the Window","text":"<p>Trying to run our program right now would result in... nothing. This is because all we are doing is simply initializing a variable. To draw our image on the screen however, we will have to create the window first.</p> Initialize Code <pre><code>(defshards initialize-character []\n(LoadImage \"GlodImages/Character1.png\") = .character-image)\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue)\n\n(GFX.Render :Steps .render-steps))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running the program now. Something happens! The window that you see was created with the code above. Changing the values in the <code>:Width</code> and <code>:Height</code> parameters will change the size of this window accordingly.</p>"},{"location":"glod-game/steps/step-1/#step-15-drawing-the-image-on-the-screen","title":"Step 1.5: Drawing the Image on the Screen","text":"<p>The last step is to draw the image on screen. To do this, we use the <code>UI.Area</code>, the <code>UI.Image</code>, and <code>GFX.Texture</code> shards.</p> <p>Create a <code>load-texture</code> shard to load our images as textures. This would make it easier for our computer to load the images and ensure that our program runs smoothly even if we use large images.</p> Code AddedFull Code So Far <pre><code>(defshards load-texture [name] ;; (1)\n(LoadImage name)\n(GFX.Texture))\n</code></pre> <ol> <li>The <code>load-texture</code> shard will allow our images to be loaded as textures.</li> </ol> <pre><code>  (UI.Area ;; (1)\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-image (UI.Image :Scale (float2 0.2))))\n</code></pre> <ol> <li><code>UI.Area</code> allows our image to be drawn on screen in the specified area.</li> </ol> <pre><code>(defshards load-texture [name] ;; (1)\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(load-texture \"GlodImages/Character1.png\") = .character-image)\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-image (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <ol> <li>Adding <code>[name]</code> when creating a shard allows that shard to take in an input variable. Here <code>[name]</code> will be used as the input for <code>load-texture</code>.</li> </ol> <p>Try running the program now. You should see adorable little Glod in the center of your screen.</p> <p>Congratulations! You have successfully drawn an image on the screen.</p> <p></p>"},{"location":"glod-game/steps/step-1/#recap","title":"Recap","text":"<p>In this step, we have successfully drawn an image on the screen by:</p> <ol> <li> <p>Initializing an image variable.</p> </li> <li> <p>Creating a window.</p> </li> <li> <p>Using <code>UI.Area</code> and <code>UI.Image</code> to draw our image within the window.</p> </li> </ol> <p>We would be very hard-pressed however to make a game out of a single static unchanging image. In the next step, we will learn how to dynamically change adorable Glod's image by pressing buttons.</p> <p>Good job so far and see you in the next step! \ud83d\udc4b</p>"},{"location":"glod-game/steps/step-2/","title":"Step 2","text":""},{"location":"glod-game/steps/step-2/#changing-character-images-with-button-inputs-overview","title":"Changing Character Images with Button Inputs - Overview","text":"<p>In the previous step, we successfully drew our character in a window. Eventually, we want this image to be animated.</p> <p>But slow down now!</p> <p>Before we reach that stage, let's first start with having our image change to another.</p> <p>In this step, we will learn how to have our character image change on button input.</p>"},{"location":"glod-game/steps/step-2/#step-21","title":"Step 2.1","text":"<p>For a start, let's have our program create a message when we press a button. To do this, create another <code>defshards</code> named <code>button-inputs</code>.</p> <p>We will use the shards <code>Inputs.KeyDown</code> and <code>Msg</code> to have our program show a message output in the terminal when we press directional buttons.</p> Code AddedFull Code So Far <pre><code>(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (Msg \"left\"))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (Msg \"right\"))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (Msg \"up\"))) ;; (1)\n</code></pre> <ol> <li>The code above is added to lines 8 - 19.</li> </ol> <pre><code>(button-inputs) ;; (1)\n</code></pre> <ol> <li>Added to line 44.</li> </ol> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (Msg \"left\"))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (Msg \"right\"))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (Msg \"up\")))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\nLoadTexture .character-image (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Why don't you try running the program now? Do you see the messages in the terminal?</p> <p>Great job if you did! We are off to a good start.</p> <p></p>"},{"location":"glod-game/steps/step-2/#step-22","title":"Step 2.2","text":"<p>Next, instead of just having messages appear on the terminal, let's start trying to get the image to change. Similar to step 1, we first load the images into variables. Add these images into the GlodImages folder and name them appropriately.</p> <ul> <li>Download the Images here.</li> </ul> Code AddedFull Code So Far <pre><code>(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping) ;; (1)      \n</code></pre> <ol> <li><code>.character-left</code>, <code>.character-right</code>, and <code>.character-jumping</code> are added to lines 5 - 9.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (Msg \"left\"))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (Msg \"right\"))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (Msg \"up\")))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-image (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now, let's draw the new images onto the screen. Place them under the same <code>UI.Area</code>.</p> Code AddedFull Code So Far <pre><code>(defshards initialize-character []\n.character-left (UI.Image :Scale (float2 0.2))\n.character-right (UI.Image :Scale (float2 0.2))\n.character-jumping (UI.Image :Scale (float2 0.2))) ;; (1)      \n</code></pre> <ol> <li><code>.character-left (UI.Image)</code>, <code>.character-right (UI.Image)</code>, <code>.character-jumping (UI.Image)</code> are added to <code>UI.Area</code>'s <code>Contents</code> at line 44, 45, and 46.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (Msg \"left\"))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (Msg \"right\"))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (Msg \"up\")))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-image (UI.Image :Scale (float2 0.2))\n.character-left (UI.Image :Scale (float2 0.2))\n.character-right (UI.Image :Scale (float2 0.2))\n.character-jumping (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running the program. Don't panic! You are supposed to see four images stacked on top of each other.</p> <p></p> <p>The next step is to have the window draw only one image at a time.</p>"},{"location":"glod-game/steps/step-2/#step-23","title":"Step 2.3","text":"<p>To have only one image drawn each time, we will:</p> <ol> <li> <p>Create a <code>.character-state</code> variable for Glod.</p> </li> <li> <p>Draw only one image based on the character state using the <code>Match</code> shard.</p> </li> </ol> States <p>Creating states is a way to have our characters and stages hold different modes, forms and levels.</p> <p>For example, a boss can have a normal mode and an enraged mode. We create the variables <code>.normal-mode</code> and <code>.enraged-mode</code>.</p> <p>When <code>.normal-mode</code> is <code>true</code> and <code>.enraged-mode</code> is <code>false</code>, the boss is in normal mode. Vice-versa, when <code>.enraged-mode</code> is <code>true</code> and <code>.normal-mode</code> is <code>false</code>, the boss will go into enraged mode.</p> <p>We will use the same logic to create states for our character and have the image shown on screen change when its state is changed.</p> <p>First, create the <code>.character-state</code> variable.</p> Code AddedFull Code So Far <pre><code>0 &gt;= .character-state ;; (1)      \n</code></pre> <ol> <li>Added under <code>initialize-character</code> at line 11.</li> </ol> <pre><code>.character-state\n(Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false) ;; (1)     \n</code></pre> <ol> <li>Added to the <code>UI.Area</code> at line 45 - 50.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (Msg \"left\"))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (Msg \"right\"))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (Msg \"up\")))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>If you run the code now, you will see only one image this time.</p> <p>However, the image does not change.</p> <p>This is because our <code>.character-state</code> has a value of 0 and stays at 0. Our <code>Match</code> shard will only return the image that is shown when <code>.character-state</code> is 0.</p> <p>To change the image, we must first change the value of the <code>.character-state</code> variable.</p> <p>Update the <code>button-inputs</code> shard to let it modify the value of <code>.character-state</code>.</p> Code AddedFull Code So Far <pre><code>(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))  </code></pre> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now if you run the code and press the up, left and right directional buttons, you will see Glod's image change! Congratulations.</p>"},{"location":"glod-game/steps/step-2/#recap","title":"Recap","text":"<p>Try running the code. Walah! You now have an image that changes based on the button pressed.</p> <p>We achieved this by:</p> <ol> <li> <p>Creating a <code>.character-state</code> variable.</p> </li> <li> <p>Using a <code>Match</code> shard to dictate which image is drawn in the window based on the value of <code>.character-state</code>.</p> </li> </ol> <p>In the next step we will breathe more life into adorable Glod by animating him!</p> <p>Looking forward to seeing you in the next step!\ud83d\ude42</p>"},{"location":"glod-game/steps/step-3/","title":"Step 3","text":""},{"location":"glod-game/steps/step-3/#animating-with-image-arrays-overview","title":"Animating with Image Arrays - Overview","text":"<p>In the last step, we managed to have Glod's image change based on directional key input.</p> <p>Now, let's breathe more life into him.</p> <p>Instead of having static images, we can have him animated. To do this we will:</p> <ol> <li> <p>Use an image array to house the different frames in an animation.</p> </li> <li> <p>Display a single frame in <code>UI.Area</code> using <code>UI.Image</code>.</p> </li> <li> <p>Cycle through the image shown by going through the image array with <code>Step</code> to create a looping animation.</p> </li> </ol> <p>Without further ado, let's get to it!</p>"},{"location":"glod-game/steps/step-3/#step-31","title":"Step 3.1","text":"<p>Before we can create our animation, we have to download the images that will be used.</p> <p>Create a folder within \"GlodImages\" and name it \"Character_Idle\". Within the \"Character_Idle\" folder, create another folder named \"Idle_Left\" and save the images there.</p> <p></p> <ul> <li>Download Glod's adorable idle animation frames here.</li> </ul>"},{"location":"glod-game/steps/step-3/#step-32","title":"Step 3.2","text":"<p>Once you have the images downloaded, the next step is to have an image array to house these images. </p> Code AddedFull Code So Far <pre><code>;; ---------- Character Idle Array ---------- ;; (1)\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array  </code></pre> <ol> <li>Remember to use <code>;;</code> comments to help segment and organize your code for better readability!</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-image (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> &gt;&gt; <p><code>&gt;&gt;</code> is an alias for the shard <code>Push</code>. An alias is a short form of a shard to make coding much easier. Think of it like typing \"lol\" instead of \"laughing out loud\". The <code>Push</code> shard is used to add an element to the back of an array.</p>"},{"location":"glod-game/steps/step-3/#step-33","title":"Step 3.3","text":"<p>Now that we have an array of images, we can take an element from this array and draw that specific image in the window. To do this:</p> <ol> <li> <p>Create a variable called <code>.idle-image-index</code>. This will determine the index of the image array that will be used.</p> </li> <li> <p>Use the <code>Take</code> shard to retrieve the image located in the specified index of the image array.</p> </li> <li> <p>Tell <code>UI.Area</code> to draw the image.</p> </li> </ol> Code AddedFull Code So Far <pre><code>0 &gt;= .idle-image-index ;; (1)\n</code></pre> <ol> <li>Added to line 22, within <code>initialize-character</code>.</li> </ol> <pre><code>.idle-left-image-array (Take .idle-image-index) ;; (1)\n</code></pre> <ol> <li><code>.character-image</code> is renamed to <code>.idle-left-image-array</code> to better reflect its idling state at line 68.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n0 &gt;= .idle-image-index)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-3/#step-34","title":"Step 3.4","text":"<p>We're almost there!</p> <p>To have this image animated, we need to dynamically increase the value of <code>.idle-image-index</code> and make it loop. To do this, we will first create a Wire that increases <code>.idle_image_index.</code></p> Code Added <pre><code>(defloop idle-animation ;; (1)\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index)\n</code></pre> <ol> <li>Use <code>defloop</code> to create a looping Wire that will add 1 to <code>.idle-image-index</code> each time it is called. Added to lines 24 - 26.</li> </ol> <p>Updating Variables</p> <p>Whenever you make changes to a variable, remember to reassign it to the variable again at the end if you plan on using it in another segment of the code.</p> Full Code So Far <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n0 &gt;= .idle-image-index)\n\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index)\n\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Before we can call this Wire, we have to create some variables to help us loop it properly.</p> <p>If we were to try to use this Wire as it is, <code>.idle-image-index</code> will increase in value indefinitely.</p> <p>To prevent this from happening, we will create some variables and a conditional statement to control how <code>.idle-image-index</code> increases.</p> Code AddedFull Code So Far <pre><code>(Count .idle-left-image-array) = .idle-image-index-max ;; (1)\n0.08 = .idle-animation-speed ;; (2)\n</code></pre> <ol> <li><code>.idle-image-index-max</code> will be used to ensure that <code>.idle-image-index</code>does not exceed this value. Added to line 23.</li> <li><code>idle-animation-speed</code> ensures how fast our idle animation will play. Added to line 24.</li> </ol> <pre><code>;; --------- Idle Animation Loop ---------\n(defloop idle-animation ;; (3)\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When ;; (1)\n:Predicate (IsMoreEqual .idle-image-index-max) :Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed)) ;; (2)\n</code></pre> <ol> <li> <p>The <code>When</code> conditional statement ensures that <code>.idle-animation-index</code> will not exceed <code>.idle-image-index-max</code>. This ensures that we will not try to draw an image that is beyond what the array has as it will crash the program.</p> </li> <li> <p><code>Pause</code> is used as this <code>defloop</code> will eventually execute <code>Step</code>. This pause will cause the <code>defloop</code> to be called at the speed indicated by <code>.idle-animation-speed</code>.</p> </li> <li> <p>Added to lines 28 - 34.</p> </li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now we just have to call this Wire in our main Wire with <code>Step</code>. </p> Step <p><code>Step</code> schedules and runs another Wire on the Wire calling <code>Step</code> itself.</p> Code AddedFull Code So Far <pre><code>(Step idle-animation) ;; (1)\n</code></pre> <ol> <li><code>Step</code> allows us to run a code in parallel to the main Wire. This line is added to line 62.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(Step idle-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-left (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .character-right (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Phew, that was a pretty long step! \ud83d\ude2a But it was worth it! Try running the code now. Tadah! You now have an animated idle image.</p>"},{"location":"glod-game/steps/step-3/#step-35","title":"Step 3.5","text":"<p>Before we proceed to the next chapter, let's give Glod more animations.</p> <p>We will be:</p> <ol> <li> <p>Using the same logic to give Glod his walk animation.</p> </li> <li> <p>Creating the logic to ensure that he faces the correct direction when the corresponding buttons are pressed. </p> </li> </ol> <p>Create the appropriate folders and save the images accordingly:</p> <ul> <li> <p>Download Glod's \"Walking Right\" animation here.</p> </li> <li> <p>Download Glod's \"Walking Left\" animation here.</p> </li> <li> <p>Download Glod's \"Idle Right\" animation here.</p> </li> </ul> Jumping Frame <p>There is no animation for jumping. Instead, it retains a single image while jumping.</p> <p>2D characters feel more responsive when they transit immediately between jumping and walking/idling. This is achieved by using only a single frame.</p> <p>Similar to how we created an image array for the idle animation when Glod is facing left, we will now create one for when Glod is facing right.</p> Code Added <pre><code>  ;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array ;; (1)\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n</code></pre> <ol> <li>Added to line 22.</li> </ol> <p>Create image arrays for when Glod is walking left and for when Glod is walking right. Since the walking animation is different from the idle animation, we will be making new variables for:</p> <ul> <li> <p>Animation speed</p> </li> <li> <p>Image index</p> </li> <li> <p>Max image index</p> <pre><code>  ;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array ;; (1)\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n</code></pre> <ol> <li>Added to line 35.</li> </ol> </li> </ul> <p><code>.character-left</code>, <code>.character-right</code> are updated to display an image from their respective arrays.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n\n.walking-left-image-array (Take .walking-image-index) ;; (1)\n.walking-right-image-array (Take .walking-image-index)\n```\n\n1. Update lines 115 - 116.\n</code></pre> Full Code So Far <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(Step idle-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Create a Wire for the walking animation and <code>Step</code> it.</p> Code AddedFull Code So Far <pre><code> ;; -------- Walking Animation Loop --------\n(defloop walking-animation ;; (1)\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n</code></pre> <ol> <li>Added to line 67.</li> </ol> <pre><code>  (Step walking-animation) ;; (1)\n</code></pre> <ol> <li>Added to line 104.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-3/#step-36","title":"Step 3.6","text":"<p>If you tried running the program, you might notice some problems.</p> <p>Namely:</p> <ol> <li>Glod does not return to his idle animation.</li> <li>Glod's jumping animation only faces right.</li> </ol> <p>Let's fix these problems.</p> <p>Why don't we start with the easier one first? Let's get Glod to return to his idle animation when we are not pressing any buttons.</p> <p>To do this we will:</p> <ol> <li> <p>Use <code>Inputs.KeyUp</code>.</p> </li> <li> <p>Create a variable that tracks which direction Glod is facing towards.</p> </li> </ol> Code Added <pre><code>0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right ;; (1)\n</code></pre> <ol> <li>Added to line 12 under <code>initialize-character</code>.</li> </ol> <p>;; ------- Button Inputs ---------- (defshards button-inputs [] ;; (1)   (Inputs.KeyDown    :Key \"left\"    :Action    (-&gt;     (Msg \"left\")     1 &gt; .character-state     0 &gt; .character-direction))</p> <p>(Inputs.KeyDown ;; (3)    :Key \"right\"    :Action    (-&gt;     (Msg \"right\")     2 &gt; .character-state     1 &gt; .character-direction))</p> <p>(Inputs.KeyDown    :Key \"up\"    :Action    (-&gt;      (Msg \"up\")      3 &gt; .character-state))</p> <p>(Inputs.KeyUp ;; (2)    :Key \"left\"    :Action     (-&gt;     0 &gt; .character-state))</p> <p>(Inputs.KeyUp    :Key \"right\"    :Action    (-&gt;     0 &gt; .character-state))) ```</p> <ol> <li> <p>Added to line 78.</p> </li> <li> <p>When the left and right buttons are released, <code>.character-state</code> will revert back to 0.</p> </li> <li> <p>When the left and right buttons are pressed <code>.character-direction</code> will be 0 and 1 respectively.</p> </li> </ol> <p>Lastly, we will add another <code>Match</code> nested within <code>Match [0(-&gt;)]</code> so that Glod displays the correct image based on his direction.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n  (Match [0 (-&gt; .character-direction\n                (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                        1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                        :Passthrough false))\n          1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n          2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n          3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n          :Passthrough false)\n```\n</code></pre> Full Code So Far <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .character-image\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state)))\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; LoadTexture .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; LoadTexture .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; LoadTexture .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; LoadTexture .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; LoadTexture .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>When you run the programme, Glod will  return to his idle animation whenever you stop pressing the left, right or up buttons and he should be facing the correct direction. Now we have to do the same thing for our jump animation</p> <ul> <li>Download Jumping Image here.</li> </ul> Code AddedFull Code So Far <pre><code>;; -------------- Character Jumping  ----------\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n</code></pre> <p>Add in a jumping right image and rename our original .character-jumping to .character-jumping-left added to line 5 - 7.</p> <pre><code>(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)\n</code></pre> <p>Then add another Match to our original Match to show the corresponding jump image depending on Glod's direction.Code added to lines 127-137.</p> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt; \n(Msg \"up\") 3 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-3/#recap","title":"Recap","text":"<p>Try running the code now! Your adorable Glod should be fully animated and will now face the correct directions.</p> <p>Congratulations on making your first animated character in Shards.</p> <p>To recap, in this step, we used arrays of images to animate Glod. Next, we will break the chains that bind Glod down and give him the power to move.</p> <p>See you in the next chapter! \ud83d\ude04</p>"},{"location":"glod-game/steps/step-4/","title":"Step 4","text":""},{"location":"glod-game/steps/step-4/#moving-the-character-with-button-inputs-overview","title":"Moving the Character with Button Inputs - Overview","text":"<p>In the previous chapter, we breathed some life into Glod and transformed him from a static image into a fully animated character.</p> <p>Amazing!</p> <p>However, we can take things further. Let's free Glod from his stationary curse and make him move! To do this we will:</p> <ol> <li>Place a variable in the <code>Position</code> tag of <code>UI.Area</code>.</li> <li>Change this variable to make Glod move.</li> <li>Use velocity and acceleration concepts to make Glod jump.</li> </ol>"},{"location":"glod-game/steps/step-4/#step-41","title":"Step 4.1","text":"<p>First, let's edit our code a little. Currently, Glod is situated in the center of the screen. While this can work, we can instead change his current <code>Anchor.Center</code> to <code>Anchor.Top</code>, and bring him down to Earth by changing his position. We achieve this by creating some variables.</p> <p>While any anchor will work as long as we change the position accordingly, we will be using <code>Anchor.Top</code> to keep things consistent and manage the positions of the different game elements more effectively.</p> <p>Create the <code>.x</code> and <code>.y</code> variables which will be used to create the variable <code>.character-position</code>.</p> Code Added <pre><code>0.0 &gt;= .x ;; (1)\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n</code></pre> <ol> <li>Added under <code>initialize-character</code>, at line 14.</li> </ol> <p><code>.character-position</code> is then fed into the <code>Position</code> parameter of the <code>UI.Area</code> shard. When the <code>.x</code> and <code>.y</code> values are changed, the <code>UI.Area</code> will move and hence move our character.</p> <p>Remember to change the <code>Anchor</code> to <code>Anchor.Top</code>!</p> Code AddedFull Code So Far <pre><code>(UI.Area\n:Position .character-position ;; (1)\n:Anchor Anchor.Top\n:Contents\n</code></pre> <ol> <li>Code edited at line 138.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt; \n(Msg \"up\") 3 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-4/#step-42","title":"Step 4.2","text":"<p>Now that our variables are set up, it's time to make Glod move! Let's start by moving him to the left and right.</p> <p>To do this, we simply have to change the <code>.x</code> value that we have just created whenever the left and right buttons are pressed.</p> <p>First, create a new variable named <code>.character-x-velocity</code>. We will change this value when the right and left directional buttons are pressed to make our character move.</p> Code Added <pre><code>0.0 &gt;= .character-x-velocity ;; (1)\n</code></pre> <ol> <li>Added to <code>initialize-character</code> at line 17.</li> </ol> <p>Create the <code>run-logic</code> shard. When <code>.character-x-velocity</code> is changed, it will be added to <code>.x</code> and <code>.character-position</code> will be updated accordingly.</p> Code Added <pre><code>;; ------------ Character Run Logic ----------------\n(defshards run-logic [] ;; (1)\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position)\n</code></pre> <ol> <li>Added to line 83.</li> </ol> <p>Update the value of <code>.character-x-velocity</code> whenever the left or right directional buttons are pressed. Remember to reset the value back to 0 when the buttons are released. If not, Glod will move to the left or right forever.</p> Code AddedFull Code So Far <pre><code>;; ------- Button Inputs ----------\n(defshards button-inputs [] ;; (1)\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt; \n(Msg \"up\") 3 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n</code></pre> <ol> <li>Updated within the <code>button-inputs</code> shard at line 90.</li> </ol> <pre><code>(run-logic) ;; (1)\n</code></pre> <ol> <li><code>run-logic</code> is added to the <code>main-wire</code> at line 134.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position)\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt; \n(Msg \"up\") 3 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-4/#step-43","title":"Step 4.3","text":"<p>Oh no! We now have a problem. \ud83e\udd72</p> <p>If we continue moving Glod left or right, you might notice that he goes off-screen.</p> <p>Let's set up a boundary to ensure that Glod does not fall off the edge and into the abyss. To do this, create a clamp function that limits how far our x value can go.</p> Code Added <pre><code>;; ---------- Character Boundary ------------ ;; (1)\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n</code></pre> <ol> <li>Added to line 82.</li> </ol> <p>This clamp function takes in a value and makes sure that it does not exceed the minimum and maximum values.</p> <p>Call our <code>clamp</code> function in <code>run-logic</code> and set the <code>var</code> parameter to be <code>.x</code>, the <code>min</code> parameter to be -600, and the <code>max</code> parameter to be 600. </p> <p>Note</p> <p>You can change the <code>min</code> and <code>max</code> parameters to fit your screen accordingly.</p> Code AddedFull Code So Far <pre><code>(clamp .x -600.0 600.0) ;; (1)\n</code></pre> <ol> <li>Added to line 93.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt; \n(Msg \"up\") 3 &gt; .character-state))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Yay! Now Glod will not walk off into the void! \ud83d\ude19</p>"},{"location":"glod-game/steps/step-4/#step-44","title":"Step 4.4","text":"<p>Now, let's make Glod jump!</p> <p>Instead of just using velocity, we can add acceleration into the mix. This will make Glod's jump feel more amazing.</p> Jumping using Velocity &amp; Acceleration <p>For smooth realistic jumping, we have to decrease velocity by acceleration whenever we jump. Decreasing velocity by acceleration decreases the rate of increase of <code>.y</code>.</p> <p>This simulates gravity, making our jump feel more realistic.</p> <p>First, create the variables that we will use.</p> Code Added <pre><code>0.0 &gt;= .character-y-velocity ;; (1)\n0.0 &gt;= .character-y-acceleration\n</code></pre> <ol> <li>Added to lines 18 and 19.</li> </ol> <p>Similar to <code>run-logic</code>, we will add <code>.character-y-velocity</code> to our <code>.y</code> variable. This time however, we will also add .<code>character-y-acceleration</code> to <code>.character-y-velocity</code>.</p> Code Added <pre><code>;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic [] ;; (1)\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position)\n</code></pre> <ol> <li>Added to line 98.</li> </ol> <pre><code>(gravity-logic) ;; (1)\n</code></pre> <ol> <li>Added to line 160 in <code>main-wire</code>.</li> </ol> <p>Lastly we modify the value of <code>.character-y-velocity</code> and <code>.character-y-acceleration</code> whenever the Up directional button is pressed.</p> Code AddedFull Code So Far <p><pre><code>(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n-20.0 &gt; .character-y-velocity ;; (1)\n1.0 &gt;  .character-y-acceleration))\n</code></pre> 1. Added to line 140 in <code>button-inputs</code>.</p> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position)\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Since our <code>Anchor</code> is set to <code>Anchor.Top</code>, it places the <code>UI.Area</code> at the top and in the middle of the screen. This is now our origin at (0,0).</p> <p>In Shards, increasing the value of the y-axis pushes our <code>UI.Area</code> down while decreasing it pushes it up.</p> <p>This is why our velocity is a negative value. When added to our <code>.y</code> value, it decreases <code>.y</code> and makes our image move upwards.</p> <p>Similarly, our acceleration is a positive value so that when it gets added to our negative value velocity, it decreases it.</p>"},{"location":"glod-game/steps/step-4/#step-45","title":"Step 4.5","text":"<p>Try running your code now! </p> <p>Oh no, we have a problem. Glod falls through the floor! \ud83d\ude28</p> <p>Don't worry, we can fix this!</p> <p>Similar to how we made a boundary to ensure that Glod does not walk off-screen, we can add a boundary to ensure he doesn't fall through the floor by reusing the same <code>clamp</code> function we made in the previous step.</p> <p>First, call our <code>clamp</code> function in <code>gravity-logic</code> with <code>.y</code> as our <code>var</code>, -620 as our <code>min</code>, and 620 as our <code>max</code>.</p> Code Added <pre><code>(clamp .y -620.0 620.0) ;; (1)\n</code></pre> <ol> <li>Added to lines 107.</li> </ol> <p>Next, add a conditional statement to ensure that our y velocity and acceleration reverts back to 0 when Glod is on the ground.</p> Code AddedFull Code So Far <pre><code>.y ;; (1)\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration))\n</code></pre> <ol> <li>Added to line 108.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration)))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Congratulations! Glod can now move and jump safely! \ud83d\ude0a</p>"},{"location":"glod-game/steps/step-4/#step-46","title":"Step 4.6","text":"<p>Finally, let's polish up the code a little.</p> <p>You might have noticed other small problems: </p> <ol> <li>Glod does not go back to his idle animation when he lands on the floor.</li> <li>Glod changes to his running animation if we move left and right while jumping.</li> <li>Glod can continuously jump as long as you press the jump button.</li> </ol> <p>Let's fix these problems!</p> <p>For the first issue, we simply have to ensure that Glod goes back to his idle animation when he reaches the floor.</p> <p>In <code>gravity-logic</code>, revert <code>character-state</code> to 0 when the character is jumping.</p> Code AddedFull Code So Far <pre><code>  .y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\n.character-state ;; (1)\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state))))\n</code></pre> <ol> <li>Added to line 114, under <code>gravity-logic</code>.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n1 &gt; .character-state\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n2 &gt; .character-state\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Here, we use a nested <code>When</code> conditional statement to ensure that Glod goes back to his idle animation only when he is jumping.</p> <p>Had we simply put <code>0 &gt;. character-state</code> without the nested <code>When</code>, this would revert Glod back to his idle animation but it would cause another problem. That is, Glod will forever be in his idle animation whenever he is on the ground. This means that he will never transit into his walking animation.</p> <p>This is why we use the nested <code>When</code> conditional statement instead.</p> <p>The second problem is also an easy fix. We simply put a <code>When</code> conditional statement to make Glod go into his walking animation when he is idling (<code>.character-state</code> is 0) and not jumping.</p> Code AddedFull Code So Far <pre><code>(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n.character-state ;; (1)\n(When\n:Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n</code></pre> <ol> <li>Edited from line 127 onwards.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>For the last problem, although slightly more complicated, we will employ the <code>When</code> conditional statement too to solve it.</p> <p>First, create a <code>.can-jump</code> variable under <code>initialize-character</code>.</p> Code Added <pre><code>true &gt;= .can-jump ;; (1)\n</code></pre> <ol> <li>Added to line 13.</li> </ol> <p>Set it such that Glod cannot jump again when he is jumping. When the jump button is pressed, <code>.can-jump</code> becomes false.</p> <p>The increase in velocity and acceleration to make Glod jump only happens when <code>.can-jump</code> is true.</p> Code Added <pre><code>(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump ;; (1)\n(When\n:Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n</code></pre> <ol> <li>Edited from line 153 onwards.</li> </ol> <p>Lastly we reset <code>.can-jump</code> back to true when Glod touches the floor again.</p> Code AddedFull Code So Far <pre><code>.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump ;; (1)\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state))))\n</code></pre> <ol> <li>Edited from line 115 onwards.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\ntrue &gt;= .can-jump\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When\n:Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n(defloop main-wire\n(Setup\n(initialize-character))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-4/#recap","title":"Recap","text":"<p>Try running your code now! Glod should be happily running and jumping without any glitches. \ud83d\ude01</p> <p>To recap:</p> <ol> <li> <p>We made Glod move by tying a variable to the <code>UI.Area</code> position and changing said variable.</p> </li> <li> <p>We ensured that Glod does not walk or fall into the void by creating boundaries.</p> </li> <li> <p>We created conditional statements to fix several problems.</p> </li> </ol> <p>And walah! We now have a fully functional moving character!</p> <p>In the next chapter, let's have Glod collect some coins! \ud83e\udd11</p>"},{"location":"glod-game/steps/step-5/","title":"Step 5","text":""},{"location":"glod-game/steps/step-5/#dropping-coins-and-scoring-points-overview","title":"Dropping Coins and Scoring Points - Overview","text":"<p>Good job on reaching this far!</p> <p>Now that we have a moving character, we can add more game elements.</p> <p>As mentioned in the intro, this will be a point collection game. We'll start by creating coins for Glod to collect.</p> <p>In this chapter we will be:</p> <ol> <li> <p>Drawing a coin image on screen.</p> </li> <li> <p>Having it move by using variables.</p> </li> <li> <p>Creating a spawning system to randomly spawn coins on the screen.</p> </li> <li> <p>Creating a collision system to have Glod be able to collect coins.</p> </li> <li> <p>Reusing code to create more coins by making shards accept arguments.</p> </li> </ol>"},{"location":"glod-game/steps/step-5/#step-51","title":"Step 5.1","text":"<p>Drawing an image on screen and using variables to move them... Does that not sound familiar? \ud83e\udd14</p> <p>Yes! It is using the same logic to make Glod appear on the screen. Download the images that we will be using:</p> <ul> <li>Download Coin Images here.</li> </ul> <p>Let's start off nice and easy by first drawing the coin image on the screen.</p> <p>Create a new <code>initialize-coin</code> shard. We will separate the initializing of our coin and character variables to make our code neater.</p> Code Added <pre><code>;; -------------- Initialize Coin ----------\n(defshards initialize-coin [] ;; (1)\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") = .coin-1)\n</code></pre> <ol> <li>Added to line 177.</li> </ol> <p>Remember to call <code>initialize-coin</code> in the <code>Setup</code> of the <code>main-wire</code>to ensure that these variables are only created once.</p> Code Added <pre><code>(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)) ;; (1)\n</code></pre> <ol> <li>Added to line 183.</li> </ol> <p>We then create a new <code>UI.Area</code> to draw the coin on the screen.</p> Code AddedFull Code So Far <pre><code>(UI.Area ;; (1)\n:Position (float2 0 0)\n:Anchor Anchor.Top\n:Contents (-&gt; .coin-1 (UI.Image :Scale (float2 0.2)))\n</code></pre> <ol> <li>Added to line 218.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\ntrue &gt;= .can-jump\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When\n:Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") = .coin-1)\n\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))\n\n(UI.Area\n:Position (float2 0 0)\n:Anchor Anchor.Top\n:Contents (-&gt; .coin-1 (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-5/#step-52","title":"Step 5.2","text":"<p>Try running your code now. You should see a coin being drawn on the top of the screen.</p> <p>Congrats!</p> <p>We are off to a good start. Now, let's animate this coin.</p> <p>The logic will be exactly the same as when we animated Glod. This will be much easier however as we won't need any conditional statements to control the coin.</p> <ul> <li>Download coin images here.</li> </ul> <p>Just like what we did to animate Glod, we replace the singular image with an array of images.</p> <p>We also create variables for controlling the Coin animation:</p> <ul> <li> <p><code>.coin-image-index</code></p> </li> <li> <p><code>.coin-image-index-max</code></p> </li> <li> <p><code>.coin-animation-speed</code></p> </li> </ul> Code Added <p>;; -------------- Initialize Coin ---------- (defshards initialize-coin [] ;; (1)   (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array   (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max   0 &gt;= .coin-image-index   0.1 &gt;= .coin-animation-speed)</p> <ol> <li>Updated <code>initialize-coin</code> at line 177.</li> </ol> <p>Then we create a <code>coin-animation</code> loop that follows the same logic as Glod's animations.</p> Code Added <p>;; -------------- Coin Animation ------------------ (defloop coin-animation   .coin-image-index (Math.Add 1)</p> <p>.coin-image-index   (When    :Predicate (IsMore .coin-image-index-max)    :Action (-&gt; 0 &gt; .coin-image-index))</p> <p>(Pause .coin-animation-speed)) </p> <ol> <li>Added to line 190.</li> </ol> <p>Remember to <code>Step</code> into the Coin's animation in your <code>main-wire</code>!</p> Code Added <p>(Step coin-animation) ;; (1)</p> <ol> <li>Added to line 210.</li> </ol> <p>Lastly, update your coin's <code>UI.Area</code> to draw the image located in an index of <code>.coin-image-array</code>. The index used is determined by the value of <code>.coin-image-index</code>.</p> Code AddedFull Code So Far <p>(UI.Area  :Position (float2 0 0)  :Anchor Anchor.Top  :Contents  (-&gt; .coin-image-array      (Take .coin-image-index)      (UI.Image :Scale (float2 0.2))))</p> <ol> <li>Added to line 239.</li> </ol> <p>(defshards load-texture [name]   (LoadImage name)   (GFX.Texture))</p> <p>(defshards initialize-character []   (LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array   (LoadTexture \"GlodImages/Character1_Left.png\") = .character-left   (LoadTexture \"GlodImages/Character1_Right.png\") = .character-right   (LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping</p> <p>0 &gt;= .character-state   0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right   true &gt;= .can-jump</p> <p>0.0 &gt;= .x   310.0 &gt;= .y   (float2 .x .y) &gt;= .character-position   0.0 &gt;= .character-x-velocity   0.0 &gt;= .character-y-velocity   0.0 &gt;= .character-y-acceleration</p> <p>;; ---------- Character Idle Array (Facing Left)----------   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array</p> <p>;; ---------- Character Idle Array (Facing Right) ----------------   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array   (LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array</p> <p>0 &gt;= .idle-image-index   (Count .idle-left-image-array) = .idle-image-index-max   0.08 = .idle-animation-speed</p> <p>;; -------------- Walking Array (Facing Left) -----------------   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array</p> <p>;; ----------- Walking Array (Facing Right) ---------------   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array   (LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array</p> <p>(Count .walking-left-image-array) = .walking-image-index-max   0 &gt;= .walking-image-index   0.08 = .walking-animation-speed ;; Reduce number to increase animation speed   )</p> <p>;; --------- Idle Animation Loop --------- (defloop idle-animation   .idle-image-index (Math.Add 1)</p> <p>.idle-image-index   (When    :Predicate (IsMoreEqual .idle-image-index-max)    :Action (-&gt; 0 &gt; .idle-image-index))   (Pause .idle-animation-speed))</p> <p>;; -------- Walking Animation Loop -------- (defloop walking-animation   .walking-image-index (Math.Add 1)</p> <p>.walking-image-index   (When    :Predicate (IsMoreEqual .walking-image-index-max)     :Action (-&gt; 0 &gt; .walking-image-index))   (Pause .walking-animation-speed))</p> <p>;; ---------- Character Boundary ------------ (defshards clamp [var min max]   var (Max min) (Min max) &gt; var)</p> <p>;; ------------ Character Run Logic ---------------- (defshards run-logic []   .x (Math.Add .character-x-velocity)</p> <p>.x</p> <p>(float2 .x .y) &gt; .character-position</p> <p>(clamp .X -600.0 600.0))</p> <p>;; ------------ Character Gravity Logic --------------- (defshards gravity-logic []   .y (Math.Add .character-y-velocity)</p> <p>.y</p> <p>.character-y-velocity (Math.Add .character-y-acceleration)</p> <p>.character-y-velocity</p> <p>(float2 .x .y) &gt; .character-position</p> <p>(clamp .y -620.0 620.0)   .y   (When    :Predicate (IsMoreEqual 620.0)    :Action (-&gt;             0.0 &gt; .character-y-velocity             0.0 &gt; .character-y-acceleration             true &gt; .can-jump             .character-state             (When              :Predicate (Is 3)              :Action (-&gt;                       0 &gt; .character-state)))))</p> <p>;; ------- Button Inputs ---------- (defshards button-inputs []   (Inputs.KeyDown    :Key \"left\"    :Action    (-&gt;     (Msg \"left\")     .character-state     (When      :Predicate (Is 0)      :Action (-&gt; 1 &gt; .character-state))     0 &gt; .character-direction     -5.0 &gt; .character-x-velocity))</p> <p>(Inputs.KeyDown    :Key \"right\"    :Action    (-&gt;     (Msg \"right\")     .character-state     (When      :Predicate (Is 0)      :Action (-&gt; 2 &gt; .character-state))     1 &gt; .character-direction     5.0 &gt; .character-x-velocity))</p> <p>(Inputs.KeyDown    :Key \"up\"    :Action    (-&gt;     (Msg \"up\")     3 &gt; .character-state     .can-jump     (When      :Predicate (Is true)      :Action (-&gt;               -20.0 &gt; .character-y-velocity               1.0 &gt;  .character-y-acceleration               false &gt;= .can-jump))))</p> <p>(Inputs.KeyUp    :Key \"left\"    :Action     (-&gt;     0 &gt; .character-state     0.0 &gt; .character-x-velocity))</p> <p>(Inputs.KeyUp    :Key \"right\"    :Action    (-&gt;     0 &gt; .character-state     0.0 &gt; .character-x-velocity)))</p> <p>;; -------------- Initialize Coin ---------- (defshards initialize-coin []   (LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array   (LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array   (Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max   0 &gt;= .coin-image-index   0.1 &gt;= .coin-animation-speed)</p> <p>;; -------------- Coin Animation ------------------ (defloop coin-animation   .coin-image-index (Math.Add 1)</p> <p>.coin-image-index   (When    :Predicate (IsMore .coin-image-index-max)    :Action (-&gt; 0 &gt; .coin-image-index))</p> <p>(Pause .coin-animation-speed))   </p> <p>(defloop main-wire   (Setup    (initialize-character)    (initialize-coin))</p> <p>(run-logic)   (gravity-logic)</p> <p>(Step idle-animation)   (Step walking-animation)</p> <p>(Step coin-animation)</p> <p>(GFX.MainWindow    :Title \"MainWindow\" :Width 1920 :Height 1080    :Contents    (-&gt;     (Setup      (GFX.DrawQueue) &gt;= .ui-draw-queue      (GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)     .ui-draw-queue (GFX.ClearQueue)</p> <pre><code>(UI\n .ui-draw-queue\n (-&gt;\n  (UI.Area\n   :Position .character-position\n   :Anchor Anchor.Top\n   :Contents\n   (-&gt;\n    .character-state\n    (Match [0 (-&gt; .character-direction\n                  (Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n                          1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n                         :Passthrough false))\n            1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n            2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n            3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n           :Passthrough false)))\n\n  (UI.Area\n   :Position (float2 0 0)\n   :Anchor Anchor.Top\n   :Contents\n   (-&gt; .coin-image-array\n       (Take .coin-image-index)\n       (UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n</code></pre> <p>(defmesh main) (schedule main main-wire) (run main (/ 1.0 60))</p> <p>Try running your code to see if your coin is animated. Good job if it is!</p>"},{"location":"glod-game/steps/step-5/#step-53","title":"Step 5.3","text":"<p>Now let's make our coin fall. To do this, like we did with Glod, we will:</p> <ol> <li> <p>Set a variable in the <code>Position</code> parameter of the coin's <code>UI.Area</code>, replacing the <code>(float2 0 0)</code> used previously.</p> </li> <li> <p>Change this variable accordingly.</p> </li> </ol> <p>Without further ado, let's get started!</p> <p>First we create the coin's x, y, and position variables.</p> Code Added <pre><code>;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1 ;; (1)\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n</code></pre> <ol> <li>Added to line 190.</li> </ol> <p>We then replace the value of the <code>Position</code> parameter in our coin's <code>UI.Area</code>.</p> Code AddedFull Code So Far <pre><code>(UI.Area\n:Position .coin-position-1 ;; (1)\n:Anchor Anchor.Top\n:Contents\n(-&gt; .coin-image-array\n(Take .coin-image-index)\n(UI.Image :Scale (float2 0.2))))\n</code></pre> <ol> <li>Amended at line 245.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\ntrue &gt;= .can-jump\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When\n:Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 &gt;= .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When\n:Predicate (IsMore .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))   (defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))\n\n(UI.Area\n:Position .coin-position-1\n:Anchor Anchor.Top\n:Contents\n(-&gt; .coin-image-array\n(Take .coin-image-index)\n(UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try changing the <code>.coinx-1</code> or <code>.coiny-1</code> values to check if your coin's position changes. Wonderful!</p> <p>Now, similar to our running and jumping logic, we have to create a gravity logic to make our coin fall. Let's once again use velocity and acceleration to make our coin fall realistically.</p> <p>First, create velocity and acceleration variables under the <code>initialize-coin</code> shard.</p> Code Added <pre><code>0.0 &gt;= .coin-velocity-1 ;; (1)\n0.5 &gt;= .coin-acceleration\n</code></pre> <ol> <li>Added to line 188, under <code>initialize-coin</code>.</li> </ol> <p>Create our <code>coin-gravity-logic</code> shard. The logic behind it is the same as our jump logic. We add velocity to the y position and then add acceleration to our velocity to increase the rate of increase.</p> Code Added <pre><code>;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [] ;; (1)\n\n.coiny-1 (Math.Add .coin-velocity-1)\n&gt; .coiny-1\n\n.coin-velocity-1 (Math.Add .coin-acceleration)\n&gt; .coin-velocity-1\n\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n</code></pre> <ol> <li>Added to line 207.</li> </ol> <p>Remember to call the <code>coin-gravity-logic</code> shard in our <code>main-wire</code> loop.</p> Code AddedFull Code So Far <pre><code>(coin-gravity-logic) ;; (1)\n</code></pre> <ol> <li>Added to line 229.</li> </ol> <pre><code>(defshards load-texture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1.png\") = .idle-left-image-array\n(LoadTexture \"GlodImages/Character1_Left.png\") = .character-left\n(LoadTexture \"GlodImages/Character1_Right.png\") = .character-right\n(LoadTexture \"GlodImages/Character1_Jumping.png\") = .character-jumping\n\n0 &gt;= .character-state\n0 &gt;= .character-direction ;; 0 = facing left, 1 = facing right\ntrue &gt;= .can-jump\n\n0.0 &gt;= .x\n310.0 &gt;= .y\n(float2 .x .y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left)----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed ;; Reduce number to increase animation speed\n)\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When\n:Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When\n:Predicate (IsMoreEqual .walking-image-index-max) :Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- Character Boundary ------------\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.x (Math.Add .character-x-velocity)\n&gt; .x\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character Gravity Logic ---------------\n(defshards gravity-logic []\n.y (Math.Add .character-y-velocity)\n&gt; .y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .x .y) &gt; .character-position\n\n(clamp .y -620.0 620.0)\n.y\n(When\n:Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When\n:Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action\n(-&gt;\n(Msg \"left\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action\n(-&gt;\n(Msg \"right\")\n.character-state\n(When\n:Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action\n(-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When\n:Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action\n(-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 &gt;= .coin-animation-speed\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When\n:Predicate (IsMore .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))   ;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n.coiny-1 (Math.Add .coin-velocity-1)\n&gt; .coiny-1\n\n.coin-velocity-1 (Math.Add .coin-acceleration)\n&gt; .coin-velocity-1\n\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(coin-gravity-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area\n:Position .character-position\n:Anchor Anchor.Top\n:Contents\n(-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt; .character-jumping (UI.Image :Scale (float2 0.2)))]\n:Passthrough false)))\n\n(UI.Area\n:Position .coin-position-1\n:Anchor Anchor.Top\n:Contents\n(-&gt; .coin-image-array\n(Take .coin-image-index)\n(UI.Image :Scale (float2 0.2))))))\n\n(GFX.Render :Steps .render-steps)\n\n(button-inputs))))\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-5/#step-54","title":"Step 5.4","text":"<p>If you run your code now, you would see our coin falling! Nice. \ud83d\ude01</p> <p>Now let's have adorable Glod chase some money! \ud83e\udd11\ud83d\udcb0\ud83d\udcb5\ud83d\udcb6\ud83d\udcb7</p> <p>To do that, we need to create the logic to:</p> <ol> <li> <p>Check when Glod is colliding with our coin.</p> </li> <li> <p>Gain a point when the collision happens.</p> </li> </ol> <p>Let's do this step by step.</p> <p>First, nice and easy, let's create a <code>.score</code> variable. Remember to initialize this in your main loop setup.</p> Code Added <p><pre><code>(defshards initialize-game-elements []\n0 &gt;= .score)\n</code></pre> <pre><code>(initialize-game-elements)\n</code></pre></p> <p>Next, create a new <code>UI.Area</code> to draw our <code>.score</code> using <code>UI.Label</code>. Remember to convert our <code>.score</code> to a string first with the <code>(ToString)</code> shard.</p> Code Added <pre><code>(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\n.score (ToString)(UI.Label)))\n</code></pre> <p>If you try to run our code now you will see a teeny tiny 0 in the corner of your screen. This means that our score is being drawn! But it unfortunately has not been styled yet. So let's do that.</p> <p>We first create a style shard and then call this shard before we draw our <code>UI.Label</code>. Now if you try running your code you would see that our score is styled nicely.</p> Code AddedFull Code So Far <p><pre><code>;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n</code></pre> <pre><code>;; ------ UI Style --------\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.Score (ToString)(UI.Label))) ;;(1)\n</code></pre></p> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n\n0.5 &gt;= .coin-acceleration)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n.coiny-1 (Math.Add .coin-velocity-1)\n&gt; .coiny-1\n\n.coin-velocity-1 (Math.Add .coin-acceleration)\n&gt; .coin-velocity-1\n\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score)\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(coin-gravity-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-5/#step-55","title":"Step 5.5","text":"<p>Now that we have our score UI, we can start to increase it. To do this, we need our collision logic.</p> <p>Create:</p> <ol> <li> <p>An upper and lower x limit.</p> </li> <li> <p>An upper and lower y limit.</p> </li> </ol> <p>This is to draw a collision box around our dear Glod. These variables are added to our <code>initialize-game-elements</code> shard. Since our character is moving, we have to constantly update our collision box.</p> <p>Glod Collision Box</p> <p>We also create a <code>.scored</code> variable to limit the number of times we can score from one coin. These variables will be added under <code>initialize-game-elements</code>.</p> Code Added <pre><code>.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\nfalse &gt;= .scored\n</code></pre> <p>Next, we will implement our collision logic with a conditional statement.</p> <p>Create the logic to trigger whenever our coin falls within our collision box.</p> <p>This conditional statement will check if the x value of our coin:</p> <ul> <li> <p>Is lesser then the upper x limit of our collision box.</p> </li> <li> <p>Is more than the lower x limit of our collision box.</p> </li> </ul> <p>It is checking if it within the stated range and does the same for the y value. Next, we increase the score whenever this happens.</p> <p>Whenever the <code>.scored</code> variable is true, gain a point. Once a point is gained, Reset <code>.scored</code> to false once again. This ensures that only one point is gained whenever we collect a coin. Remember to call the <code>(scoring)</code> shard in your main wire</p> Code AddedFull Code So Far <pre><code>;; ------------- Scoring ------------\n(defshards score-collision []\n.coinx-1\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\n.coinx-1 (IsMore .scoringLower-x-limit)\n(And)\n.coiny-1 (IsLess .scoringUpper-y-limit)\n(And)\n.coiny-1 (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit (score-collision)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n\n0.5 &gt;= .coin-acceleration)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n.coiny-1 (Math.Add .coin-velocity-1)\n&gt; .coiny-1\n\n.coin-velocity-1 (Math.Add .coin-acceleration)\n&gt; .coin-velocity-1\n\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\nfalse &gt;= .scored)\n\n; ------------- Scoring ------------\n(defshards score-collision []\n.coinx-1\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\n.coinx-1 (IsMore .scoringLower-x-limit)\n(And)\n.coiny-1 (IsLess .scoringUpper-y-limit)\n(And)\n.coiny-1 (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(coin-gravity-logic)\n\n(scoring)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running your code now and see if you get a point. You did!? Congratulations!</p>"},{"location":"glod-game/steps/step-5/#step-56","title":"Step 5.6","text":"<p>Now that we have a scoring system, let's create more coins.</p> <p>Currently, we have only one coin falling down. Let's reuse this coin and have it appear again in another random x position for Glod to run after and collect.</p> <p>Here we are creating a loop that will give our coin a random x value and reset its y value. It will do this every one and a half seconds. This means that our coin will randomly spawn, fall, and then one and a half seconds later, randomly spawn and fall again.</p> Code Added <pre><code>;; ---------- Random Coin ------------\n(defloop random-coin\n.coinx-1\n(RandomFloat :Max 1200.0)\n&gt; .coinx-1\n(Math.Subtract 600.0)\n&gt; .coinx-1\n\n0.0 &gt; .coiny-1\n0.0 &gt; .coin-velocity-1\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1\n(Pause 1.5))\n</code></pre> <p>Remember to <code>Step</code> into your loop in your main wire.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n(Step  random-coin) ;; (1)      \n```\n</code></pre> Full Code So Far <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n\n0.5 &gt;= .coin-acceleration)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic []\n\n.coiny-1 (Math.Add .coin-velocity-1)\n&gt; .coiny-1\n\n.coin-velocity-1 (Math.Add .coin-acceleration)\n&gt; .coin-velocity-1\n\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n;; ------------- Random Coin ------------------\n(defloop random-coin\n.coinx-1\n(RandomFloat :Max 1200.0)\n&gt; .coinx-1\n(Math.Subtract 600.0)\n&gt; .coinx-1\n\n0.0 &gt; .coiny-1\n0.0 &gt; .coin-velocity-1\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1\n(Pause 1.5))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\nfalse &gt;= .scored)\n\n; ------------- Scoring ------------\n(defshards score-collision []\n.coinx-1\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\n.coinx-1 (IsMore .scoringLower-x-limit)\n(And)\n.coiny-1 (IsLess .scoringUpper-y-limit)\n(And)\n.coiny-1 (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements))\n\n(run-logic)\n(gravity-logic)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(coin-gravity-logic)\n(Step  random-coin)\n\n(scoring)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running your code now!</p> <p>Congrats, you have a very basic game. You can try it out and have fun chasing coins! \ud83d\ude01</p>"},{"location":"glod-game/steps/step-5/#step-57","title":"Step 5.7","text":"<p>While we have a basic game on our hands now, we can still polish it further. Currently, we only have one coin spawning. Let's have more! To do this, we have to change some of our shards to accept arguments instead of having hard coded variables.</p> <p>Create some new variables for our second coin. These variables are added under <code>initialize-coin</code>.</p> Code Added <pre><code>;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n</code></pre> <p>Next, create a <code>UI.Area</code> to draw our new coin. You can try running your code at this point to make sure that your coin is being drawn.</p> Code Added <pre><code>(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n</code></pre> <p>Now to make it fall...</p> Code Added <pre><code>;; ###### DON'T DO THIS ########\n(defshards coin-gravity-logic []\n\n.coiny-1 (Math.Add .coin-velocity-1)\n&gt; .coiny-1\n\n.coin-velocity-1 (Math.Add .coi-acceleration)\n&gt; .coin-velocity-1\n\n(float2 .coinx-1 .coiny-1) &gt; .coin-position-1)\n\n(defshards coin-gravity-logic-2 []\n\n.coiny-2 (Math.Add .coin-velocity-1)\n&gt; .coiny-2\n\n.coin-velocity-2 (Math.Add .coin-acceleration)\n&gt; .coin-velocity-2\n\n(float2 .coinx-2 .coiny-2) &gt; .coin-position-2)\n</code></pre> <p>While the above code can work, our code will end up being very messy. Instead, let's have our original <code>coin-gravity-logic</code> shard take in arguments instead.</p> <p>Here we convert our original <code>coin-gravity-logic</code> shard into one that takes arguments. Now that we have this, rather than duplicating this code a million times, we can call it as many times as required and simply pass it the correct variables.</p> Code Added <pre><code>;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n</code></pre> <pre><code>(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n</code></pre> <p>We'll do the same for our coin randomizing logic.</p> <p>Now you might be wondering how do we get our <code>random-coin</code> logic to accept arguments as it is a <code>defloop</code> and not a <code>defshards</code>.</p> <p>Do not fret!</p> <p>To do this, we simply change our current <code>defloop</code> into a <code>defshards</code> that accepts arguments and create a new <code>defloop</code> that calls this new <code>defshards</code> as shown below.</p> Code Added <pre><code>;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n</code></pre> <pre><code>(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n</code></pre> <pre><code>(Step random-coin-1)\n(Step random-coin-2)\n</code></pre> <p>Now, last but not least, we will convert our scoring logic into a <code>defshards</code> that accepts arguments.</p> Code AddedFull Code So Far <pre><code>;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n\n(Step idle-animation)\n(Step walking-animation)\n(Step coin-animation)\n\n(Step random-coin-1)\n(Step random-coin-2)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now with all the pieces in place, we can add as many coins as we want.</p> <p>In this tutorial we will stick to just four coins, but you can create as many as you want! </p> <p>Just remember to follow the same process and flow as the above to make sure that you don't miss out something.</p> <p>In summary:</p> <ol> <li> <p>Create the necessary variables for your new coins.</p> </li> <li> <p>Create a new <code>UI.Area</code> for each of your new coins.</p> </li> <li> <p>Make sure your new coins fall by adding new <code>coin-gravity-logic</code>.</p> </li> <li> <p>Make sure your coins loop and randomize by adding a new <code>random-coin-loop</code>.</p> </li> <li> <p>Make sure you can earn points from them by adding a new <code>score-collision</code>.</p> </li> </ol>"},{"location":"glod-game/steps/step-5/#recap","title":"Recap","text":"<p>Phew that was a really long step!</p> <p>Good job for making it through. \ud83d\ude01\ud83c\udf89</p> <p>To recap:</p> <ul> <li> <p>We made a coin fall by using the same logic to make our character move.</p> </li> <li> <p>We created a scoring system by making a collision system.</p> </li> <li> <p>We set up a system to create as many coins as we want by making our <code>defshards</code> accept arguments.</p> </li> </ul> <p>Phew! That was a mouthful but worth it!</p> <p>In the next chapter, we will use the same logic to create falling hazards for Glod!</p> <p>See you! \ud83d\udc4b\ud83c\udffc\ud83d\ude00</p>"},{"location":"glod-game/steps/step-6/","title":"Step 6","text":""},{"location":"glod-game/steps/step-6/#making-the-game-harder-overview","title":"Making the Game Harder - Overview","text":"<p>We are almost towards the end of the tutorial. Wahoo!</p> <p>In the previous chapter, we learnt how to make coins for Glod to collect.</p> <p>In this chapter, we will do the opposite. We will make the game more challenging by creating hazards for Glod to avoid!</p> <p>Poor Glod. \ud83d\ude22</p> <p>To do this we will be:</p> <ol> <li> <p>Drawing a spiked cannonball image on screen.</p> </li> <li> <p>Having it move using variables.</p> </li> <li> <p>Creating a spawning system to randomly spawn a spiked cannonball on screen.</p> </li> <li> <p>Creating a collision system to allow Glod to be hit.</p> </li> <li> <p>Reusing code to create more Spiked Cannonballs by making shards accept arguments.</p> </li> </ol> <p>If you are wondering why the list above seems familiar, it is because the exact same logic and methods were used in the previous chapter.</p> <p>Let's get to it. \ud83d\udd25</p>"},{"location":"glod-game/steps/step-6/#step-61","title":"Step 6.1","text":"<p>We start off nice and easy by downloading the required images and displaying one of them on the screen.</p> <ol> <li>Download spiked cannonball images here.</li> </ol> <p>Load one image first. To keep our code organized, create a new <code>initialize-spiked-cannonballs</code> shard.</p> Code Added <pre><code>;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") = .spikeball-1)\n</code></pre> <p>Remember to call your new shard in <code>main-wire</code>.</p> Code Added <pre><code>(initialize-spiked-canonballs) ;; (1)\n</code></pre> <p>To draw our loaded image, create a <code>UI.Area</code>.</p> Code AddedFull Code So Far <pre><code>(UI.Area :Position (float2 0 0)\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-1 (UI.Image :Scale (float2 0.15))))\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture\"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") = .spikeball-1)\n\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n\n(Step idle-animation)\n(Step walking-animation)\n(Step coin-animation)\n\n(Step random-coin-1)\n(Step random-coin-2)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-1 (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-6/#step-62","title":"Step 6.2","text":"<p>Similar to what we did with our coin, it's time to animate our spiked cannonball.</p> <p>Follow these steps to create an animation once more:</p> <ol> <li> <p>Create an <code>Image</code> array.</p> </li> <li> <p>Create the necessary variables - an index, max index, and animation speed variable.</p> </li> </ol> Code Added <pre><code>;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) (Math.Subtract 1) &gt;= .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 &gt;= .spikeball-animation-speed\n</code></pre> <p>Create an animation loop that uses the variables we created. This loop should add one to our index every iteration. It should also have a conditional statement that ensures that our index does not go above the <code>index-max</code>.</p> <p>Lastly, the loop should loop every x seconds, with x being the animation speed.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n  .spikeball-index (Math.Add 1)\n  &gt; .spikeball-index\n  (When :Predicate (IsMore .spikeball-array-index-max)\n        :Action (-&gt; 0 &gt; .spikeball-index))\n\n  (Pause .spikeball-animation-speed))\n```\n</code></pre> <p>As with all loops, remember to <code>Step</code> it in <code>main-wire</code>.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n(Step spiked-canonball-animation) ;; (1)\n\n```\n</code></pre> <p>Remember to update our spiked cannonball's <code>UI.Area</code> to display the correct image in the image array, as specified by <code>.spikeball-index</code>.</p> <pre><code>```{.clojure .annotate linenums=\"1\"}\n;; ------------ Character Run Logic ----------------\n;; -------- Spiked CanonBall UI.Area ----------\n(UI.Area :Position (float2 0 0)\n                  :Anchor Anchor.Top\n                  :Contents (-&gt;\n                            .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n```\n</code></pre> Full Code So Far <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-6/#step-63","title":"Step 6.3","text":"<p>Time to make our spiked cannonball fall.</p> <p>As in the previous chapter, we will:</p> <ol> <li> <p>Create variables that dictate the position of our spiked cannonball.</p> </li> <li> <p>Change our <code>UI.Area</code>'s <code>position</code> parameter to use this variable.</p> </li> <li> <p>Change the variable by using velocity and acceleration.</p> </li> </ol> <p>Initialize the code variables that we will be using to move our spiked cannonball.</p> Code Added <pre><code>;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n0.5 &gt;= .spikeball-acceleration\n</code></pre> <p>Locate the <code>UI.Area</code> housing our spiked cannonball image.</p> <p>Replace the value of the <code>Position</code> attribute with the <code>.spikeball-position-1</code> variable.</p> Code Added <pre><code>;; -------- Spiked CanonBall UI.Area ----------\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n</code></pre> <p>To make our image move, we create the gravity logic for it.</p> <p>Create a shard that accepts arguments to allow for the creating of more spiked cannonballs in the future.</p> Code Added <pre><code>;; ------------- SpikeBall Gravity Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n</code></pre> <p>Remember to call your shard in the <code>main-wire</code> with the appropriate variables passed in.</p> Code AddedFull Code So Far <pre><code>(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Try running your code now to see if it falls!</p>"},{"location":"glod-game/steps/step-6/#step-64","title":"Step 6.4","text":"<p>To make sure that our spiked cannonball loops and randomly spawns in different locations, we will implement the same spawning logic used previously.</p> <p>Create our <code>randomise-spikeball</code> logic. Similar to our coin, we reset the spiked cannonball's y value back to zero, so that it appears at the top of the screen again.</p> <p>This time however, we will have different randomized x values and have this happen every <code>pausefloat</code> number of seconds.</p> Code Added <pre><code>;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n</code></pre> <p>We then plug this shard into a loop and fill in the appropriate variables.</p> Code Added <pre><code>(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n</code></pre> <p>Call your <code>spikeball-1</code> loop in the <code>main-wire</code>.</p> Code AddedFull Code So Far <pre><code>;; ------- Button Inputs ----------\n(Step spikeball-1)\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(Step  spikeball-1)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-6/#step-65","title":"Step 6.5","text":"<p>Now that we have our spiked cannonball looping and randomizing, the next step is to have it damage Glod.</p> <p>Poor Glod. \ud83d\ude22</p> <p>It will follow the same logic as our coin. However, instead of gaining points when Glod collides with it, points will be lost.</p> <p>Create the variables that we will be using. They are similar to the collision box we used for scoring.</p> <p>Add this to the <code>initialize-game-elements</code> shard.</p> Code Added <pre><code>;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged\n</code></pre> <p>Create the logic to dictate what happens when our spiked cannonball hits Glod. Remember to call this in <code>main-wire</code>.</p> Code AddedFull Code So Far <pre><code>;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n</code></pre> <pre><code>;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\nfalse &gt; .damaged)))\n</code></pre> <pre><code>(damaging)\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n;;------------ Scoring Limits ----------\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\nfalse &gt; .damaged)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(Step  spikeball-1)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now that we have our spiked cannonball system up, we can create as many as we want. And since we already set up our shards to take in arguments, this time it would be much easier!</p> <p>Create more spiked cannonballs.</p> <p>All we have to do is to follow these easy steps:</p> <ol> <li> <p>Create the variables for our new spiked cannonball.</p> </li> <li> <p>Create new <code>UI.Area</code> for each new spiked cannonball.</p> </li> <li> <p>Add in <code>spikeball-gravity-logic</code> to ensure it falls.</p> </li> <li> <p>Add in <code>randomise_spikeball_logic</code> to ensure that it randomizes.</p> </li> <li> <p>Ensure that Glod get's damaged whenever he gets hit.</p> </li> </ol> Code AddedFull Code So Far <pre><code>;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n</code></pre> <p>Step 1 ! Create the variables</p> <pre><code>(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n</code></pre> <p>Step 2 ! Create the UI.Area</p> <pre><code>(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n</code></pre> <p>Step 3 ! Add the Gravity logic</p> <pre><code>(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n</code></pre> <pre><code>(Step  spikeball-2)\n(Step  spikeball-3)\n</code></pre> <p>Step 4 ! Add the Randomise logic!</p> <pre><code>(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n</code></pre> <p>Step 5 ! Add the collision logic (remember this is in our damaging shard)</p> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n;;------------ Scoring Limits ----------\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\nfalse &gt; .damaged)))\n\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-6/#recap","title":"Recap","text":"<p>Good job in reaching this far!</p> <p>In this chapter, we created falling spiked cannonballs using the same logic as our coins.</p> <p>In the next chapter, we will round off and finish the game by adding a few more elements that will be the icing on the cake for our game.</p> <p>Almost there! \ud83d\ude00 </p> <p>See you in the next chapter.</p>"},{"location":"glod-game/steps/step-7/","title":"Step 7","text":""},{"location":"glod-game/steps/step-7/#polishing-up-the-game","title":"Polishing up the Game","text":"<p>At this point in the tutorial, we already possess a fully functional game that we can have fun playing.</p> <p>However, it could use some polishing to add more flair and make it more exciting... and that is what we will be doing in the final step of the tutorial.</p> <p>We will be:</p> <ol> <li> <p>Adding a visual effect that happens when Glod collects a coin.</p> </li> <li> <p>Adding a visual effect that happens when Glod is hit by a spiked cannonball.</p> </li> <li> <p>Adding a background image.</p> </li> <li> <p>Adding a timer and a Game Over screen.</p> </li> <li> <p>Adding a reset function to play the game again.</p> </li> </ol> <p>So let's get to it! \ud83d\udcaa\ud83c\udffc</p>"},{"location":"glod-game/steps/step-7/#visual-effect-for-collecting","title":"Visual Effect for Collecting","text":"<p>To make collecting more satisfying, we will add a visual feedback that happens whenever Glod collects a coin.</p> <p>This will use the same logic and principles as when creating an animation.</p> <ul> <li>Download Scoring Effect Images here.</li> </ul> <p>Visual Feedback</p> <p>\"Feedback is information relayed to the player in response to an in-game interaction.\"  - Liam Charlton , Game Design Psychology: Signs &amp; Feedback   Here we use positive visual feedback to make it more satisfying whenever a player collects coins. The sense of satisfaction encourages the player to want to play more and continue playing.</p> <p>We also use negative visual feedback when a player collides with a spiked cannonball to discourage them from getting hit.</p> <p>Feedback can come in many forms - tactile, auditory, visual, and even as rewards!</p> <p>What are some feedback from your favorite games that you have found effective?</p> <p>You should be familiar with creating animations by now!</p> <p>As per before, let us create a new shard <code>initialize-effects</code> that will house all the variables that we need. Remember to call <code>initialize-effects</code> under <code>Setup</code> in <code>main-wire</code>.</p> Code Added <pre><code>;; ------------- initialize effects -------------\n(defshards initialize-effects []\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position)\n</code></pre> <pre><code>(initialize-effects)\n</code></pre> <p>Next we create a <code>UI.Area</code> that will house our animation.</p> Code Added <pre><code>;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n</code></pre> <p>We adjust the value of <code>.character-x-velocity</code> whenever the left and right directional keys are pressed.</p> <p>Remember to return the value of <code>.character-x-velocity</code> to zero when the directional keys are released - otherwise Glod will move to the left or right forever!</p> Code Added <pre><code>;; ------------ ScoreEffect Animation Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n</code></pre> <pre><code>;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n.score-effect-play\n(When\n:Predicate (Is true)\n:Action\n(-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When\n:Predicate (IsMore .score-effect-array-index-max)\n:Action\n(-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n(Pause .score-effect-animation-speed))\n</code></pre> <p>Next we have some logic to loop and play our animation. This animation plays when <code>.score-effect-play</code> is true.</p> <p>This variable will then go false at the end of the animation for it to stop. This is the technique to use when you want an animation to only play once.</p> Code Added <pre><code>true &gt; .score-effect-play\n</code></pre> <p>Then remember to make <code>.score-effect-play</code> true whenever we collect a coin. We can add this line in our scoring code that we have written previously.</p> Code Added <pre><code>(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n</code></pre> <p>Lastly, remember to call your shard and loop in your <code>main-wire</code>.</p> Full Code So Far <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n;;------------ Scoring Limits ----------\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\ntrue &gt; .score-effect-play\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\nfalse &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position)\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n.score-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When :Predicate (IsMore .score-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n\n\n(Pause .score-effect-animation-speed))\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs)\n(initialize-effects))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; ---------- Coins -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n;; ------------SpikeBalls ------------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now, it should be more fun for you to collect coins! \ud83d\udcb0</p>"},{"location":"glod-game/steps/step-7/#step-72","title":"Step 7.2","text":"<p>Now following the same logic, we will create feedback for when we are damaged.</p> <ul> <li>Download Damage Effect images here.</li> </ul> <p>Create all the variables that we need for creating animations. Add it under <code>initialize-effects</code>.</p> Code Added <pre><code>;; --------------- Damaged Effect ----------------\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play\n</code></pre> <p>Create a <code>UI.Area</code> which will house our animation.</p> Code Added <pre><code>(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n</code></pre> <p>Create our logic to loop our damage effect animation which plays when <code>.damage-effect-play</code> is true.</p> Code Added <pre><code>;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n.damage-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.damage-effect-array-index (Math.Add 1)\n&gt; .damage-effect-array-index\n(When :Predicate (IsMore .damage-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .damage-effect-array-index\nfalse &gt; .damage-effect-play))))\n\n\n(Pause .damage-effect-animation-speed))\n</code></pre> <p>Make <code>.damage-effect-play</code> <code>true</code> whenever we collide with our spiked cannonballs. This will be added to our <code>spikeball-damage-logic</code>, which we have created earlier.</p> Code AddedFull Code So Far <pre><code>true &gt; .damage-effect-play\n</code></pre> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n;;------------ Scoring Limits ----------\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\ntrue &gt; .score-effect-play\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\ntrue &gt; .damage-effect-play\nfalse &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n;; --------------- Damaged Effect ----------------\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play)\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n.damage-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.damage-effect-array-index (Math.Add 1)\n&gt; .damage-effect-array-index\n(When :Predicate (IsMore .damage-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .damage-effect-array-index\nfalse &gt; .damage-effect-play))))\n\n(Pause .damage-effect-animation-speed))\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n.score-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When :Predicate (IsMore .score-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n\n\n(Pause .score-effect-animation-speed))\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs)\n(initialize-effects))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n(Step damage-effect-animation-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; ---------- Coins -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n;; ------------SpikeBalls ------------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n;; --------------- UI Score --------------\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Good job!</p> <p>Now we have even more motivation to avoid getting hit! \ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8</p>"},{"location":"glod-game/steps/step-7/#step-73","title":"Step 7.3","text":"<p>This step will be extremely easy.</p> <p>We will simply be adding a background image to our game to make it more visually appealing.</p> <ul> <li>Download background image here.</li> </ul> <p>First, load our image.</p> Code Added <pre><code>(LoadTexture \"GlodImages/BG.png\") = .bg-image </code></pre> <p>Next, create a <code>UI.Area</code> to house our new image.</p> <p>Remember to add this <code>UI.Area</code> before the <code>UI.Area</code> which houses your character to ensure that it is drawn below your character.</p> Code AddedFull Code So Far <pre><code>(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.bg-image (UI.Image :Scale (float2 0.7))))\n</code></pre> <pre><code>(defshards initialize-character []\n(LoadImage \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadImage \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) (Math.Subtract 1) &gt;= .idle-image-index-max\n0.08 &gt;= .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) (Math.Subtract 1) &gt;= .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 &gt;= .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMore .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMore .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadImage \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 &gt;= .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMore .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadImage \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) (Math.Subtract 1) &gt;= .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 &gt;= .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMore .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\ntrue &gt; .score-effect-play\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\ntrue &gt; .damage-effect-play\nfalse &gt; .damaged)))\n\n\n;; ------------- innitialize effects -------------\n(defshards initialize-effects []\n;; --------------- Animation Effects -----------------\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.02 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n;; --------------- Damaged Effect ----------------\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play\n\n(LoadImage \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ ScoreEffect Animation Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n.score-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When :Predicate (IsMore .score-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n\n\n(Pause .score-effect-animation-speed))\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n.damage-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.damage-effect-array-index (Math.Add 1)\n&gt; .damage-effect-array-index\n(When :Predicate (IsMore .damage-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .damage-effect-array-index\nfalse &gt; .damage-effect-play))))\n\n\n(Pause .damage-effect-animation-speed))\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs)\n(initialize-effects))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n(Step damage-effect-animation-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.bg-image (UI.Image :Scale (float2 0.7))))\n\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; LoadTexture .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; LoadTexture .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; LoadTexture .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; LoadTexture .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; LoadTexture .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; LoadTexture .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; -------- coins ui area -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n;; --------- spikeball ui area ----------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nLoadTexture .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n;; ---------------- UI ------------------\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>Now we have a background image! \ud83d\uddbc\ufe0f</p>"},{"location":"glod-game/steps/step-7/#step-74","title":"Step 7.4","text":"<p>Let's make our game more challenging by adding a timer. \u23f1\ufe0f</p> <p>Create a <code>.timer</code> variable and add it under <code>initialize-game-elements</code>.</p> Code Added <pre><code>60 &gt;= .timer\n0 &gt;= .gameOver\n</code></pre> <p>Create a <code>UI.Area</code> to draw our timer variable. Place it on the top left.</p> Code Added <pre><code>(UI.Area :Position (float2 40 20)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nstyle (UI.Style)\n.timer (ToString) (UI.Label)))\n</code></pre> <p>Create a countdown logic.</p> <p>Here, we subtract one from our <code>.timer</code> variable and <code>Step</code> into the loop every second.</p> <p>Set a conditional statement to ensure that this only happens while <code>.gameOver</code> is false and <code>.timer</code> is greater than zero.</p> Code Added <pre><code>;; -------- Timer -----------\n(defloop timer-countdown\n.gameOver\n(When :Predicate (-&gt;\n(Is 0)\n(And)\n.timer (IsMore 0))\n:Action (-&gt;\n.timer (Math.Subtract 1)\n&gt; .timer))\n\n(Pause 1.0))\n</code></pre> <p>Create the Game Over logic to dictate that <code>.gameOver</code> becomes true when <code>.timer</code> reaches zero.</p> Code Added <pre><code>;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n.timer\n(When :Predicate (Is 0)\n:Action (-&gt;\n1 &gt; .gameOver)))\n</code></pre> <p>Remember to call and <code>Step</code> them in the <code>main-wire</code>.</p> Code AddedFull Code So Far <pre><code>(Step timer-countdown)\n(gameOver-logic)\n</code></pre> <pre><code>(defshards initialize-character []\n(LoadImage \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadImage \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadImage \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) (Math.Subtract 1) &gt;= .idle-image-index-max\n0.08 &gt;= .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadImage \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) (Math.Subtract 1) &gt;= .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 &gt;= .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMore .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMore .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadImage \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadImage \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) (Math.Subtract 1) &gt;= .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 &gt;= .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMore .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadImage \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadImage \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) (Math.Subtract 1) &gt;= .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 &gt;= .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMore .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged\n\n60 &gt;= .timer\n0 &gt;= .gameOver)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\ntrue &gt; .score-effect-play\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\ntrue &gt; .damage-effect-play\nfalse &gt; .damaged)))\n\n\n;; ------------- innitialize effects -------------\n(defshards initialize-effects []\n;; --------------- Animation Effects -----------------\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadImage \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.02 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n;; --------------- Damaged Effect ----------------\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadImage \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play\n\n(LoadImage \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ ScoreEffect Animation Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n.score-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When :Predicate (IsMore .score-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n\n\n(Pause .score-effect-animation-speed))\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n.damage-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.damage-effect-array-index (Math.Add 1)\n&gt; .damage-effect-array-index\n(When :Predicate (IsMore .damage-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .damage-effect-array-index\nfalse &gt; .damage-effect-play))))\n\n\n(Pause .damage-effect-animation-speed))\n\n;; -------- Timer -----------\n(defloop timer-countdown\n.gameOver\n(When :Predicate (-&gt;\n(Is 0)\n(And)\n.timer (IsMore 0))\n:Action (-&gt;\n.timer (Math.Subtract 1)\n&gt; .timer))\n\n(Pause 1.0))\n\n;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n.timer\n(When :Predicate (Is 0)\n:Action (-&gt;\n1 &gt; .gameOver)))\n\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs)\n(initialize-effects))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n(Step damage-effect-animation-logic)\n\n(Step timer-countdown)\n(gameOver-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.bg-image (UI.Image :Scale (float2 0.7))))\n\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; LoadTexture .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; LoadTexture .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; LoadTexture .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; LoadTexture .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; LoadTexture .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; LoadTexture .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; -------- coins ui area -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n;; --------- spikeball ui area ----------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\nLoadTexture .score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nLoadTexture .damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n;; ---------------- UI ------------------\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))\n\n(UI.Area :Position (float2 40 20)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nstyle (UI.Style)\n.timer (ToString) (UI.Label)))))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre>"},{"location":"glod-game/steps/step-7/#step-75","title":"Step  7.5","text":"<p>Finally its time to code the final bit for our game. We need to add some finality to our game by having it end when our Timer reaches 0. Then we also need to create a way to reset the game so that we can play it again. While this might seem daunting, don't worry! It's much easier than you might think.</p> Code AddedFull Code So Far <pre><code>;; -------- Game_Over_UI -------------\n(defloop gameOver-ui\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.Center\n:Contents (-&gt;\nstyle (UI.Style)\n\"Score\" (UI.Label)\n.score (ToString) (UI.Label)\n(UI.Button :Label \"Restart\"\n:Action (-&gt;\n0 &gt; .gameOver\n60 &gt; .timer\n0 &gt; .score\n(float2 0 0) &gt; .character-position)))))\n</code></pre> <ol> <li>First we create a defloop with a <code>UI.Area</code> that houses everything we want to show when the game is over. In this case, we want to show our player's score and then a reset button. In the reset Button's <code>:Action</code> tag, we change variables that have changed to revert the game back to it's initial state.</li> </ol> <pre><code>;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position) ;; (1)\n</code></pre> <ol> <li>Next we create the <code>run-logic</code>. When <code>.character-x-velocity</code> is changed, it will be added to <code>.X</code> and the <code>.character-position</code> will be updated accordingly Added on lines 77-82</li> </ol> <pre><code>(defloop mainGame-ui\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.bg-image (UI.Image :Scale (float2 0.7))))\n\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; ---------- Coins -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n;; ------------SpikeBalls ------------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n;; --------------- UI Score --------------\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))\n\n;; --------------- UI Timer --------------\n(UI.Area :Position (float2 40 20)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nstyle (UI.Style)\n.timer (ToString) (UI.Label))))\n</code></pre> <p>Next we shift all the UI.Area that we have created so far in main-wire to a new defloop called mainGame-ui. Now if yout ry to run your game now you will get an error as there in nothing in your main-wire to be drawn. Don't panic! All will be clear soon.</p> <pre><code>(UI\n.ui-draw-queue\n(-&gt;\n.gameOver\n(Match [0 (-&gt; (Step mainGame-ui))\n1 (-&gt; (Step gameOver-ui))]\n:Passthrough false)))\n</code></pre> <p>Now inside our <code>main-wire</code> UI, we create a <code>Match</code> shard. If <code>.gameOver</code> is 0 (false), then draw the <code>mainGame-ui</code>. If <code>.gameOver</code> is 1(true) then draw the <code>gameOver-ui.</code></p> <pre><code>(defshards LoadTexture [name]\n(LoadImage name)\n(GFX.Texture))\n\n(defshards initialize-character []\n(LoadTexture \"GlodImages/Character1_Jumping_Left.png\") = .character-jumping-left\n(LoadTexture \"GlodImages/Character1_Jumping_Right.png\") = .character-jumping-right\n\n0 &gt;= .character-state\n0 &gt;= .character-direction\ntrue &gt;= .can-jump\n\n0.0 &gt;= .X\n620.0 &gt;= .Y\n(float2 .X .Y) &gt;= .character-position\n0.0 &gt;= .character-x-velocity\n0.0 &gt;= .character-y-velocity\n0.0 &gt;= .character-y-acceleration\n\n;; ---------- Character Idle Array (Facing Left) ----------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png\") &gt;&gt; .idle-left-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png\") &gt;&gt; .idle-left-image-array\n\n;; ---------- Character Idle Array (Facing Right) ----------------\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png\") &gt;&gt; .idle-right-image-array\n(LoadTexture \"GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png\") &gt;&gt; .idle-right-image-array\n\n0 &gt;= .idle-image-index\n(Count .idle-left-image-array) = .idle-image-index-max\n0.08 = .idle-animation-speed\n\n;; -------------- Walking Array (Facing Left) -----------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png\") &gt;&gt; .walking-left-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png\") &gt;&gt; .walking-left-image-array\n\n;; ----------- Walking Array (Facing Right) ---------------\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png\") &gt;&gt; .walking-right-image-array\n(LoadTexture \"GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png\") &gt;&gt; .walking-right-image-array\n\n(Count .walking-left-image-array) = .walking-image-index-max\n0 &gt;= .walking-image-index\n0.08 = .walking-animation-speed) ;; Reduce number to increase animation speed\n\n;; --------- Idle Animation Loop ---------\n(defloop idle-animation\n.idle-image-index (Math.Add 1)\n&gt; .idle-image-index\n(When :Predicate (IsMoreEqual .idle-image-index-max)\n:Action (-&gt; 0 &gt; .idle-image-index))\n(Pause .idle-animation-speed))\n\n;; -------- Walking Animation Loop --------\n(defloop walking-animation\n.walking-image-index (Math.Add 1)\n&gt; .walking-image-index\n(When :Predicate (IsMoreEqual .walking-image-index-max)\n:Action (-&gt; 0 &gt; .walking-image-index))\n(Pause .walking-animation-speed))\n\n;; ---------- character-boundary ------------\n\n(defshards clamp [var min max]\nvar (Max min) (Min max) &gt; var)\n\n;; ------------ Character Run Logic ----------------\n(defshards run-logic []\n.X (Math.Add .character-x-velocity)\n&gt; .X\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .X -600.0 600.0))\n\n;; ------------ Character gravity-logic ---------------\n(defshards gravity-logic []\n.Y (Math.Add .character-y-velocity)\n&gt; .Y\n\n.character-y-velocity (Math.Add .character-y-acceleration)\n&gt; .character-y-velocity\n\n(float2 .X .Y) &gt; .character-position\n\n(clamp .Y -620.0 620.0)\n.Y\n(When :Predicate (IsMoreEqual 620.0)\n:Action (-&gt;\n0.0 &gt; .character-y-velocity\n0.0 &gt; .character-y-acceleration\ntrue &gt; .can-jump\n.character-state\n(When :Predicate (Is 3)\n:Action (-&gt;\n0 &gt; .character-state)))))\n\n;; ------- Button Inputs ----------\n(defshards button-inputs []\n(Inputs.KeyDown\n:Key \"left\"\n:Action (-&gt;\n(Msg \"left\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 1 &gt; .character-state))\n\n0 &gt; .character-direction\n-5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"right\"\n:Action (-&gt;\n(Msg \"right\")\n\n.character-state\n(When :Predicate (Is 0)\n:Action (-&gt; 2 &gt; .character-state))\n1 &gt; .character-direction\n5.0 &gt; .character-x-velocity))\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt;\n(Msg \"up\")\n3 &gt; .character-state\n.can-jump\n(When :Predicate (Is true)\n:Action (-&gt;\n-20.0 &gt; .character-y-velocity\n1.0 &gt;  .character-y-acceleration\nfalse &gt;= .can-jump))))\n\n(Inputs.KeyUp\n:Key \"left\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity))\n\n(Inputs.KeyUp\n:Key \"right\"\n:Action (-&gt;\n0 &gt; .character-state\n0.0 &gt; .character-x-velocity)))\n\n;; -------------- Initialize Coin ----------\n(defshards initialize-coin []\n(LoadTexture \"GlodImages/Coin/Coin_1.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_2.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_3.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_4.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_5.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_6.png\") &gt;&gt; .coin-image-array\n(LoadTexture \"GlodImages/Coin/Coin_7.png\") &gt;&gt; .coin-image-array\n(Count .coin-image-array) = .coin-image-index-max\n0 &gt;= .coin-image-index\n0.1 = .coin-animation-speed\n\n;; ----- Coin 1 ------\n0.0 &gt;= .coinx-1\n0.0 &gt;= .coiny-1\n(float2 .coinx-1 .coiny-1) &gt;= .coin-position-1\n0.0 &gt;= .coin-velocity-1\n0.5 &gt;= .coin-acceleration\n\n;; ----- Coin 2 ----\n0.0 &gt;= .coinx-2\n0.0 &gt;= .coiny-2\n(float2 .coinx-2 .coiny-2) &gt;= .coin-position-2\n0.0 &gt;= .coin-velocity-2)\n\n;; -------------- Coin Animation ------------------\n(defloop coin-animation\n.coin-image-index (Math.Add 1)\n&gt; .coin-image-index\n(When :Predicate (IsMoreEqual .coin-image-index-max)\n:Action (-&gt; 0 &gt; .coin-image-index))\n\n(Pause .coin-animation-speed))\n\n;; ------------- Coin Gravity ------------------\n(defshards coin-gravity-logic [coiny coinx coin-velocity coin-position]\n\ncoiny (Math.Add coin-velocity)\n&gt; coiny\n\ncoin-velocity (Math.Add .coin-acceleration)\n&gt; coin-velocity\n\n(float2 coinx coiny) &gt; coin-position)\n\n;; ------------- Random Coin ------------------\n(defshards random-coin [coinx coiny coin-velocity coin-position pause-length]\ncoinx\n(RandomFloat :Max 1200.0)\n&gt; coinx\n(Math.Subtract 600.0)\n&gt; coinx\n\n0.0 &gt; coiny\n0.0 &gt; coin-velocity\n(float2 coinx coiny) &gt; coin-position\n(Pause pause-length))\n\n(defloop random-coin-1\n(random-coin .coinx-1 .coiny-1 .coin-velocity-1 .coin-position-1 1.5))\n\n(defloop random-coin-2\n(random-coin .coinx-2 .coiny-2 .coin-velocity-2 .coin-position-2 2.5))\n\n;; ------------ Initialize Spiked CanonBalls ---------------\n(defshards initialize-spiked-canonballs []\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall1.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall2.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall3.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall4.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall5.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall6.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall7.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall8.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall9.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall10.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall11.png\") &gt;&gt; .spikeball-array\n(LoadTexture \"GlodImages/SpikeBall/SpikeBall12.png\") &gt;&gt; .spikeball-array\n\n(Count .spikeball-array) = .spikeball-array-index-max\n0 &gt;= .spikeball-index\n0.06 = .spikeball-animation-speed\n\n;; ---------- spikball-1 -------------\n1.0 &gt;= .spikeball-velocity-1\n0.0 &gt;= .spikeball-y-1\n0.0 &gt;= .spikeball-x-1\n(float2 .spikeball-x-1 .spikeball-y-1) &gt;= .spikeball-position-1\n\n;; ---------- spikeball-2 -------------\n1.0 &gt;= .spikeball-velocity-2\n0.0 &gt;= .spikeball-y-2\n0.0 &gt;= .spikeball-x-2\n(float2 .spikeball-x-2 .spikeball-y-2) &gt;= .spikeball-position-2\n\n;; ---------- SpikeBall_3 -------------\n1.0 &gt;= .spikeball-velocity-3\n0.0 &gt;= .spikeball-y-3\n0.0 &gt;= .spikeball-x-3\n(float2 .spikeball-x-3 .spikeball-y-3) &gt;= .spikeball-position-3\n\n0.5 &gt;= .spikeball-acceleration)\n\n;;------------- Spiked CanonBall Animation -------------\n(defloop spiked-canonball-animation\n.spikeball-index (Math.Add 1)\n&gt; .spikeball-index\n(When :Predicate (IsMoreEqual .spikeball-array-index-max)\n:Action (-&gt; 0 &gt; .spikeball-index))\n\n(Pause .spikeball-animation-speed))\n\n;; ------------- SpikeBall_Gravity_Logic -------------\n(defshards spikeball-gravity-logic [spikeball-y spikeball-velocity spikeball-position spikeball-x]\nspikeball-y (Math.Add spikeball-velocity)\n&gt; spikeball-y\nspikeball-velocity (Math.Add .spikeball-acceleration)\n&gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position)\n\n;; ------------- Randomise Spikeball ----------------\n(defshards randomise-spikeball [spikeball-x spikeball-y spikeball-velocity spikeball-position pausefloat]\nspikeball-x\n(RandomFloat :Max 1200.0)\n&gt; spikeball-x\n(Math.Subtract 600.0)\n&gt; spikeball-x\n\n0.0 &gt; spikeball-y\n0.0 &gt; spikeball-velocity\n(float2 spikeball-x spikeball-y) &gt; spikeball-position\n.spikeball-x-1\n(Pause pausefloat))\n\n(defloop spikeball-1\n(randomise-spikeball .spikeball-x-1 .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 2))\n(defloop spikeball-2\n(randomise-spikeball .spikeball-x-2 .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 3))\n(defloop spikeball-3\n(randomise-spikeball .spikeball-x-3 .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 4))\n\n;; --------- Game Elements ------------\n(defshards initialize-game-elements []\n;;------------ Scoring Limits ----------\n0 &gt;= .score\nfalse &gt;= .scored\n\n.X (Math.Add 50.0)\n&gt;= .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt;= .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt;= .scoringLower-y-limit\n\n;; ---------- Damage Limits ------------\n.X (Math.Add 50.0)\n&gt;= .damageUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt;= .damageLower-x-limit\n\n.Y (Math.Add 5.0)\n&gt;= .damageUpper-y-limit\n.Y (Math.Subtract 5.0)\n&gt;= .damageLower-y-limit\n\nfalse &gt;= .damaged\n\n60 &gt;= .timer\n0 &gt;= .gameOver)\n\n;; --------- Scoring ----------\n(defshards score-collision [coinx coiny]\ncoinx\n(When :Predicate (-&gt;\n(IsLess .scoringUpper-x-limit)\n(And)\ncoinx (IsMore .scoringLower-x-limit)\n(And)\ncoiny (IsLess .scoringUpper-y-limit)\n(And)\ncoiny (IsMore .scoringLower-y-limit)\n(And)\n.scored (Is false))\n:Action (-&gt;\ntrue &gt; .scored\n(Log \"Score: \"))))\n\n(defshards scoring []\n.X (Math.Add 50.0)\n&gt; .scoringUpper-x-limit\n.X (Math.Subtract 50.0)\n&gt; .scoringLower-x-limit\n\n.Y (Math.Add 10.0)\n&gt; .scoringUpper-y-limit\n.Y (Math.Subtract 10.0)\n&gt; .scoringLower-y-limit\n\n(score-collision .coinx-1 .coiny-1)\n(score-collision .coinx-2 .coiny-2)\n\n.scored\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Add 1)\n&gt; .score\ntrue &gt; .score-effect-play\nfalse &gt; .scored)))\n\n;; ------------- spikeBall-collision-logic --------------\n(defshards spikeBall-collision-logic [spikeBall-x spikeBall-y]\n\nspikeBall-x\n(If :Predicate (-&gt; (IsLess .damageUpper-x-limit)\n(And)\nspikeBall-x (IsMore .damageLower-x-limit)\n(And)\nspikeBall-y (IsLess .damageUpper-y-limit)\n(And)\nspikeBall-y (IsMore .damageLower-y-limit))\n\n:Then (-&gt; .damaged\n(When :Predicate (Is false)\n:Action (-&gt;\ntrue &gt; .damaged\n(Log \"damaged: \"))))))\n\n;; -------------- Damaging --------------\n(defshards damaging []\n\n.X (Math.Add 120.0)\n&gt; .damageUpper-x-limit\n.X (Math.Subtract 120.0)\n&gt; .damageLower-x-limit\n\n.Y (Math.Add 15.0)\n&gt; .damageUpper-y-limit\n.Y (Math.Subtract 15.0)\n&gt; .damageLower-y-limit\n\n(spikeBall-collision-logic .spikeball-x-1 .spikeball-y-1)\n(spikeBall-collision-logic .spikeball-x-2 .spikeball-y-2)\n(spikeBall-collision-logic .spikeball-x-3 .spikeball-y-3)\n\n.damaged\n(When :Predicate (Is true)\n:Action (-&gt;\n.score (Math.Subtract 1)\n&gt; .score\ntrue &gt; .damage-effect-play\nfalse &gt; .damaged)))\n\n;; ------------- initialize effects -------------\n(defshards initialize-effects []\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_1.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_2.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_3.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_4.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_5.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_6.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_7.png\") &gt;&gt; .score-effect-array\n(LoadTexture \"GlodImages/Coin/CoinEffect/Score_Effect_8.png\") &gt;&gt; .score-effect-array\n(Count .score-effect-array) (Math.Subtract 1) &gt;= .score-effect-array-index-max\n0 &gt;= .score-effect-array-index\n0.05 &gt;=  .score-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .score-effect-play\n\n0.0 &gt;= .score-effect-position-x\n0.0 &gt;= .score-effect-position-y\n(float2 .score-effect-position-x .score-effect-position-y) &gt;= .score-effect-position\n\n;; --------------- Damaged Effect ----------------\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_1.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_2.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_3.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_4.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_5.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_6.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_7.png\") &gt;&gt; .damage-effect-array\n(LoadTexture \"GlodImages/Damage_Effect/Damaged_Effect_8.png\") &gt;&gt; .damage-effect-array\n(Count .damage-effect-array) (Math.Subtract 1) &gt;= .damage-effect-array-index-max\n0 &gt;= .damage-effect-array-index\n0.02 &gt;=  .damage-effect-animation-speed ;; Reduce number to increase animation speed\nfalse &gt;= .damage-effect-play\n\n(LoadTexture \"GlodImages/BG.png\") = .bg-image)\n\n;; ------------ DamageEffect Animation ------------\n(defloop damage-effect-animation-logic\n\n.damage-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.damage-effect-array-index (Math.Add 1)\n&gt; .damage-effect-array-index\n(When :Predicate (IsMore .damage-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .damage-effect-array-index\nfalse &gt; .damage-effect-play))))\n\n(Pause .damage-effect-animation-speed))\n\n;; ------------ ScoreEffect_Animation_Position ------------\n(defshards scoreEffect-animation-position []\n.Y (Math.Add -15.0)\n&gt; .score-effect-position-y\n\n.X\n&gt; .score-effect-position-x\n\n(float2 .score-effect-position-x .score-effect-position-y)\n&gt; .score-effect-position)\n\n;; ------------ ScoreEffect Animation ------------\n(defloop scoreEffect-animation-logic\n\n.score-effect-play\n(When :Predicate (Is true)\n:Action (-&gt;\n.score-effect-array-index (Math.Add 1)\n&gt; .score-effect-array-index\n(When :Predicate (IsMore .score-effect-array-index-max)\n:Action (-&gt;\n0 &gt; .score-effect-array-index\nfalse &gt; .score-effect-play))))\n\n\n(Pause .score-effect-animation-speed))\n\n;; -------- Timer -----------\n(defloop timer-countdown\n.gameOver\n(When :Predicate (-&gt;\n(Is 0)\n(And)\n.timer (IsMore 0))\n:Action (-&gt;\n.timer (Math.Subtract 1)\n&gt; .timer))\n\n(Pause 1.0))\n\n;; ---------- GameOver Logic ------------\n(defshards gameOver-logic []\n.timer\n(When :Predicate (Is 0)\n:Action (-&gt;\n1 &gt; .gameOver)))\n\n;; ------ UI Style --------\n(def style\n{:override_text_style \"MyStyle\"\n:text_styles\n[{:name \"MyStyle\"\n:size (float 46)\n:family \"Monospace\"}]\n:visuals\n{:override_text_color (color 250 250 250)}})\n\n;; -------- Game_Over_UI -------------\n(defloop gameOver-ui\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.Center\n:Contents (-&gt;\nstyle (UI.Style)\n\"Score\" (UI.Label)\n.score (ToString) (UI.Label)\n(UI.Button :Label \"Restart\"\n:Action (-&gt;\n0 &gt; .gameOver\n60 &gt; .timer\n0 &gt; .score\n(float2 0 0) &gt; .character-position)))))\n\n(defloop mainGame-ui\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.bg-image (UI.Image :Scale (float2 0.7))))\n\n(UI.Area :Position .character-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.character-state\n(Match [0 (-&gt; .character-direction\n(Match [0 (-&gt; .idle-left-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .idle-right-image-array (Take .idle-image-index) (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))\n1 (-&gt; .walking-left-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n2 (-&gt; .walking-right-image-array (Take .walking-image-index) (UI.Image :Scale (float2 0.2)))\n3 (-&gt;  .character-direction\n(Match [0 (-&gt; .character-jumping-left (UI.Image :Scale (float2 0.2)))\n1 (-&gt; .character-jumping-right (UI.Image :Scale (float2 0.2)))]\n:Passthrough false))]\n:Passthrough false)))\n\n;; ---------- Coins -----------\n\n(UI.Area :Position .coin-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n(UI.Area :Position .coin-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.coin-image-array (Take .coin-image-index) (UI.Image :Scale (float2 0.2))))\n\n;; ------------SpikeBalls ------------\n\n(UI.Area :Position .spikeball-position-1\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-2\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position .spikeball-position-3\n:Anchor Anchor.Top\n:Contents (-&gt;\n.spikeball-array (Take .spikeball-index) (UI.Image :Scale (float2 0.15))))\n\n;; ----------------- Visual Effects  -------------------\n(UI.Area :Position .score-effect-position\n:Anchor Anchor.Top\n:Contents (-&gt;\n.score-effect-array (Take .score-effect-array-index) (UI.Image :Scale (float2 0.15))))\n\n(UI.Area :Position (float2 0 0)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\n.damage-effect-array (Take .damage-effect-array-index) (UI.Image :Scale (float2 10))))\n\n;; --------------- UI Score --------------\n\n(UI.Area :Position (float2 -40 20)\n:Anchor Anchor.TopRight\n:Contents (-&gt;\nstyle (UI.Style)\n.score (ToString) (UI.Label)))\n\n;; --------------- UI Timer --------------\n(UI.Area :Position (float2 40 20)\n:Anchor Anchor.TopLeft\n:Contents (-&gt;\nstyle (UI.Style)\n.timer (ToString) (UI.Label))))\n\n;;---------- main-wire ------------\n(defloop main-wire\n(Setup\n(initialize-character)\n(initialize-coin)\n(initialize-game-elements)\n(initialize-spiked-canonballs)\n(initialize-effects))\n\n(coin-gravity-logic .coiny-1 .coinx-1 .coin-velocity-1 .coin-position-1)\n(coin-gravity-logic .coiny-2 .coinx-2 .coin-velocity-2 .coin-position-2)\n\n(run-logic)\n(gravity-logic)\n(scoring)\n(damaging)\n\n(Step idle-animation)\n(Step walking-animation)\n\n(Step coin-animation)\n(Step random-coin-1)\n(Step random-coin-2)\n\n(Step spiked-canonball-animation)\n(spikeball-gravity-logic .spikeball-y-1 .spikeball-velocity-1 .spikeball-position-1 .spikeball-x-1)\n(spikeball-gravity-logic .spikeball-y-2 .spikeball-velocity-2 .spikeball-position-2 .spikeball-x-2)\n(spikeball-gravity-logic .spikeball-y-3 .spikeball-velocity-3 .spikeball-position-3 .spikeball-x-3)\n(Step  spikeball-1)\n(Step  spikeball-2)\n(Step  spikeball-3)\n\n(scoreEffect-animation-position)\n(Step scoreEffect-animation-logic)\n(Step damage-effect-animation-logic)\n\n(Step timer-countdown)\n(gameOver-logic)\n\n(GFX.MainWindow\n:Title \"MainWindow\" :Width 1920 :Height 1080\n:Contents\n(-&gt; (Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n.gameOver\n(Match [0 (-&gt; (Step mainGame-ui))\n1 (-&gt; (Step gameOver-ui))]\n:Passthrough false)))\n\n(button-inputs)\n\n(GFX.Render :Steps .render-steps))))\n\n\n(defmesh main)\n(schedule main main-wire)\n(run main (/ 1.0 60))\n</code></pre> <p>CONGRATULATIONS! \ud83c\udf89\ud83c\udf89\ud83c\udf89\ud83c\udf89\ud83c\udf89\ud83c\udf89</p> <p>You have successfully created a game!</p> <p>Give it a whirl and see how many points you can get!</p>"},{"location":"snake/","title":"Snake game tutorial","text":"<p>Welcome! In this tutorial, we will create a simple snake-like game using Shards.</p> <p>You can either follow the step by step tutorial or use the full-game version directly.</p> <ul> <li>Introduction</li> <li>Step by step</li> <li>Full game</li> </ul>"},{"location":"snake/#acknowledgments","title":"Acknowledgments","text":"<p>Gremlin Industries which made the original Blockade arcade game, and Nokia which popularized the game under the Snake name.</p> <p> </p>"},{"location":"snake/introduction/","title":"Introduction","text":""},{"location":"snake/introduction/#gameplay","title":"Gameplay","text":"<p>Snake is a simple game where the player has to move a snake by choosing a direction (up, down, left, or right). Each time the snake eats a fruit it grows by one unit in size. The goal is to continually grow the snake till it occupies all available (game) play-space. However, the game ends if the snake eats a part of its own body or hits the invisible walls (play-space borders).</p> <p> </p>"},{"location":"snake/full-game/","title":"Full game","text":"EDNResult snake.edn<pre><code>; SPDX-License-Identifier: BSD-3-Clause\n; Copyright \u00a9 2021 Fragcolor Pte. Ltd.\n\n(def grid-cols 12)\n(def grid-rows 10)\n(def empty-grid\n[0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0])\n\n(defshards get-index []\n(| (Take 0) &gt;= .x)\n(| (Take 1) &gt;= .y)\n.y (Math.Multiply grid-cols) (Math.Add .x))\n\n(defshards get-free-locations [fruit snake]\n[] &gt;= .locations\n(ForRange\n:From 0 :To (- grid-cols 1) :Action\n(-&gt; &gt;= .a\n(ForRange\n:From 0 :To (- grid-rows 1) :Action\n(-&gt; &gt;= .b\n[.a .b] (ToInt2) &gt;= .location\n(When (-&gt; snake (IndexOf .location) (Is -1) (And) fruit (IsNot .location))\n(-&gt; .location (Push .locations)))))))\n.locations)\n\n(defshards move-fruit [fruit snake]\n(get-free-locations fruit snake) &gt;= .free-loc\n(Count .free-loc) &gt;= .max\n(RandomInt .max) &gt;= .next-fruit-loc\n.free-loc (Take .next-fruit-loc) (ToInt2))\n\n(defshards move-snake [snake offset grow]\nsnake (RTake 0) (Math.Add offset) (Push snake)\n(WhenNot (-&gt; grow) (DropFront snake)))\n\n(defshards populate-grid [fruit snake]\n&gt;= .tmp-grid\n; first the snake tail and body\nsnake (Take 0) (get-index) &gt;= .tail-index\n[.tail-index 4] (Assoc .tmp-grid)\nsnake (Slice 1 -1)\n(ForEach\n(-&gt; (get-index) &gt;= .limb-index\n[.limb-index 3] (Assoc .tmp-grid)))\n; then the fruit\nfruit (get-index) &gt;= .fruit-index\n[.fruit-index 1] (Assoc .tmp-grid)\n; finally the snake head\nsnake (RTake 0) (get-index) &gt;= .head-index\n[.head-index 2] (Assoc .tmp-grid)\n; return the populated grid\n.tmp-grid)\n\n(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n]\n(if\n(= n -1)\nnil\n(-&gt;\n(| (int2\n(% n grid-cols)\n(/ n grid-cols))\n(ToFloat2)\n(Math.Multiply (float2 cell-size))\n(Math.Add (float2 x-offset y-offset)) &gt; .position)\n(| (Take n)\n(UI.Area\n:Position .position\n:Contents\n(-&gt; (Match\n[0 (-&gt; \".\") ; empty\n1 (-&gt; \"F\") ; fruit\n2 (-&gt; \"H\") ; head\n3 (-&gt; \"B\") ; body\n4 (-&gt; \"T\") ; tail\n]false)\n(UI.Label))))\n(render-cells (- n 1)))))\n\n(defshards menus []\n(UI.MenuBar\n(-&gt;\n(UI.Menu\n\"File\"\n(-&gt;\n(UI.Button \"New game\" (-&gt; (initialize) (UI.CloseMenu)))\n(UI.Separator)\n(UI.Button \"Quit\" (Stop)))))))\n\n(defshards initialize []\n[(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\nfalse &gt;= .grow\n(move-fruit (int2 0 0) .snake) &gt;= .fruit\n\"right\" &gt;= .direction &gt;= .prev-direction\n(Time.Now) &gt;= .last-tick\n; do it once to not wait the next tick\nempty-grid (populate-grid .fruit .snake) &gt;= .grid\nfalse &gt;= .game-over)\n\n(defloop main-wire\n(Once (initialize))\n; logic\n(WhenNot (-&gt; .game-over)\n; normal game\n(When (-&gt; (Time.Now) (Math.Subtract .last-tick) (IsMoreEqual 0.33))\n(-&gt; (Time.Now) &gt; .last-tick\n; move the snake\n.direction (Match [\"up\" (move-snake .snake (int2 0 -1) .grow)\n\"right\" (move-snake .snake (int2 1 0) .grow)\n\"down\" (move-snake .snake (int2 0 1) .grow)\n\"left\" (move-snake .snake (int2 -1 0) .grow)])\n\n(Count .snake) (Math.Subtract 1) &gt;= .head-idx\n.snake (Take .head-idx) &gt;= .head\n; snake eats its own body?\n(When (-&gt; .snake (IndexOf .head) (IsNot .head-idx))\n(-&gt; true &gt; .game-over))\n; snake hits a wall?\n(When (-&gt; .head (Take 0) (IsLess 0) (Or) (Take 0) (IsMoreEqual grid-cols)\n(Or)\n.head (Take 1) (IsLess 0) (Or) (Take 1) (IsMoreEqual grid-rows))\n(-&gt; true &gt; .game-over))\n; did the snake eat the fruit?\n(If (-&gt; .head (Is .fruit))\n(-&gt; true &gt; .grow\n(move-fruit .fruit .snake) &gt; .fruit)\n(-&gt; false &gt; .grow)\n:Passthrough true)\n\n(WhenNot (-&gt; .game-over)\n(-&gt; empty-grid (populate-grid .fruit .snake) &gt; .grid\n.direction &gt; .prev-direction)))))\n; window\n(GFX.MainWindow\n:Title \"Snake game\" :Width 480 :Height 360\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n(UI.TopPanel :Contents (menus))\n(UI.BottomPanel\n:Contents\n(-&gt;\n(When (-&gt; .game-over)\n(UI.Horizontal\n(-&gt; \"GAME OVER!\" (UI.Label :Style {:color (color 255 0 0)})\n(UI.Space 10.0)\n\"Final score: \" (UI.Label)\n(Count .snake) (ToString) (UI.Label))))))\n.grid\n(Setup (float2 0) &gt;= .position)\n(render-cells (- (* grid-cols grid-rows) 1))))\n\n(GFX.Render :Steps .render-steps)\n\n(Inputs.KeyDown\n\"up\"\n(When (-&gt; .prev-direction (IsNot \"down\"))\n(-&gt; \"up\" &gt; .direction)))\n(Inputs.KeyDown\n\"right\"\n(When (-&gt; .prev-direction (IsNot \"left\"))\n(-&gt; \"right\" &gt; .direction)))\n(Inputs.KeyDown\n\"down\"\n(When (-&gt; .prev-direction (IsNot \"up\"))\n(-&gt; \"down\" &gt; .direction)))\n(Inputs.KeyDown\n\"left\"\n(When (-&gt; .prev-direction (IsNot \"right\"))\n(-&gt; \"left\" &gt; .direction)))\n(Inputs.KeyDown\n\"space\" (initialize)))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre>"},{"location":"snake/steps/","title":"Steps","text":"<ul> <li>Step 1 - getting started</li> <li>Step 2 - basic window</li> <li>Step 3 - drawing the fruit, the snake, and the grid</li> <li>Step 4 - player input</li> <li>Step 5 - game over conditions and final touches</li> </ul>"},{"location":"snake/steps/step-1/","title":"Step 1","text":""},{"location":"snake/steps/step-1/#basic-file-structure","title":"Basic file structure","text":"<p>In this tutorial, we will program using a Clojure-like syntax and an EDN-like format (JSON equivalent for Clojure). The similarity of Shards' syntax to Clojure means more expressive code in fewer lines (as compared to traditional programming languages like Javascript or Python). Additionally, the code is more focused on data which makes it easier for beginners to grasp.</p> <p>A simple program in Shards would look like this:</p> EDN <pre><code>; define a wire named 'main-wire'\n(defwire main-wire\n; print a message on the standard output\n(Msg \"Hello World!\"))\n\n; define the root mesh\n(defmesh root)\n; schedule the wire on that mesh\n(schedule root main-wire)\n; run\n(run root)\n</code></pre> <p>To run the program, execute the following from the command line:</p> WindowsUnixOutput <pre><code>.\\shards.exe &lt;path\\to\\program.edn&gt;\n</code></pre> <pre><code>./shards path/to/program.edn\n</code></pre> <pre><code>[info] [2021-11-12 16:12:52.712] [T-13596] [logging.cpp::94] [main-wire] Hello World!\n</code></pre>"},{"location":"snake/steps/step-1/#game-loop","title":"Game loop","text":"<p>Contrary to simple programs (e.g. a command-line utility) that execute an operation and exit afterwards, a game typically runs for a longer time. Most games have the concept of a \"game loop\".</p> <p>A game loop is the overall flow control of the program that runs continuously during gameplay. In each turn of the loop (known as a frame), the program processes the user's input, updates the game state, and renders the game.</p> <p>In Shards, a wire (self-contained piece of code made that can be suspended/resumed and is made up of shards and functions) can be transformed into a loop by simply replacing <code>(defwire)</code> with <code>(defloop)</code>. Additionally, <code>(run)</code> takes a second argument to specify the delay between two consecutive executions of the loop, specifying the frame rate (FPS). Games tend to run at 60 FPS (or 60 Hz).</p> EDNOutput <pre><code>(defloop main-wire\n(Msg \"Hello World!\"))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <pre><code>[info] [2021-11-12 16:25:54.487] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.514] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.530] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.546] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n[info] [2021-11-12 16:25:54.562] [T-32668] [logging.cpp::94] [main-wire] Hello World!\n...\n</code></pre> <p> </p>"},{"location":"snake/steps/step-2/","title":"Step 2","text":"<p>In this tutorial, we will implement a simplified version of the snake game. For now, we won't have high-end graphics but we'll instead focus on the game logic.</p>"},{"location":"snake/steps/step-2/#defining-the-play-space","title":"Defining the play space","text":"<p>The snake evolves inside a grid. It moves one cell at a time either horizontally or vertically. The fruit that the snake must eat to grow can appear on any unoccupied cell.</p> <p>Such a grid may be defined in many ways. We could use a 2D array (or in our case, a sequence of sequences since our grid exists in two-dimensional space). However, to keep our code simple, we will instead use a flat sequence to hold the states of all our grid elements.</p> <p>The trick is to visualize the 1D sequence as a 2D matrix with defined grid row and grid column values (see code below).</p> EDN <pre><code>(def grid-cols 5) ;; (1)\n(def grid-rows 4)\n(def empty-grid\n[0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0]) ;; (2)\n</code></pre> <ol> <li>The <code>def</code> keyword associates a value with a name.</li> <li><code>[]</code> is the syntax to define a sequence of values.</li> </ol> <p>Now, to compute the index of a grid element in that sequence from its 2D coordinates, we can define the following function.</p> EDN <pre><code>(defn get-index [] ;; (1)\n(-&gt; (| (Take 0) &gt;= .x) ;; (2) (3)\n(| (Take 1) &gt;= .y) ;; (4) (5)\n.y (Math.Multiply grid-cols) (Math.Add .x))) ;; (6) (7)\n</code></pre> <ol> <li>The <code>defn</code> keyword associates a function with a name. Note the <code>[]</code> after the <code>get-index</code> name. This indicates that this function has 0 parameters. We will later see functions that do have parameters.</li> <li><code>(-&gt;)</code> is a shard container that will group and execute its inner shard(s) in order.</li> <li><code>(|)</code> is an alias for <code>(Sub)</code>. It allows reusing the same input across a sequence of shards.</li> <li><code>(Take)</code> returns the value from a sequence at a given index (starting at <code>0</code>).</li> <li><code>&gt;=</code> is an alias for the shard <code>(Set)</code> which saves the output of a shard into a context variable.</li> <li><code>(Math.Multiply)</code> multiplies its input (written to the left of the shard) with a given value (written to the right of the shard and enclosed within its brackets) and outputs the result.</li> <li><code>(Math.Add)</code> adds a value to its input and outputs the result.</li> </ol> Note <p>Because defn expects a single \"value\" (called function return value) after the function name and the list of parameters, and our function\u2019s logic (function body) contains multiple shards, a <code>(-&gt;)</code> shard is required to group these shards in a single (return) shard. Since this is a common situation with <code>(defn)</code> function, a convenient alternative is to use <code>(defshards)</code> instead. A <code>(defshards)</code> behaves exactly like a function (including the ability to accept input parameters) but can contain multiple shards in its body. These multiple shards are executed in the order that they appear and the <code>(defshards)</code> return value is the output of the last shard in its body.</p> <pre><code>(defshards get-index []\n(| (Take 0) &gt;= .x)\n(| (Take 1) &gt;= .y)\n.y (Math.Multiply grid-cols) (Math.Add .x))\n</code></pre> <p>It can be a bit confusing considering that the function doesn't have any parameters. This is because there is an implicit parameter which is the input.</p> <p>Since the <code>(Take)</code>shard statements start with a <code>(|)</code>, they both process the same input (i.e. the implicit input parameter) passed to the <code>get-index</code> function. The first statement stores the 0th element of the input (sequence) into a context variable <code>.x</code>, while the second statement stores the 1st element of the input into a context variable <code>.y</code>.</p> <p>Similarly, there is an implicit output at the end of the function (the equivalent of the <code>return</code> statement in other programming languages) which is also the function's return value.</p> <p>Let's break down the last line to understand what's happening here.</p> EDN <pre><code>.y (Math.Multiply grid-cols) (Math.Add .x)\n</code></pre> <ul> <li>Here <code>.y</code> is a context variable.</li> <li>Its value becomes the input of the next shard: <code>(Math.Multiply)</code>.</li> <li><code>(Math.Multiply)</code> takes that value, multiplies it by <code>grid-cols</code>, and returns the result as output.</li> <li>The output becomes the input for the next shard: <code>(Math.Add)</code>.</li> <li><code>(Math.Add)</code> takes that input and adds it to the value of the context variable <code>.x</code>.</li> <li>Since this is the last shard of the function, the output of this shard becomes the output of the whole function.</li> </ul> <p>Whenever this function is called, the same processing will happen.</p> EDN <pre><code>(int2 1 2) (get-index)\n</code></pre> <p>This time our input is a 2D integer vector represented as a single <code>int2</code> value. Inside <code>(get-index)</code> each component of that vector will be extracted using <code>(Take)</code> (see above code listings).</p>"},{"location":"snake/steps/step-2/#creating-a-window","title":"Creating a window","text":"<p>We will render our game as a windowed application. Therefore we first need to define a window.</p> EDNResult <pre><code>(defloop main-wire ;; (1)\n(GFX.MainWindow  ;; (2)\n:Title \"Snake game\" :Width 480 :Height 360))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <ol> <li>We have already seen <code>defloop</code>, <code>defmesh</code>, <code>schedule</code> and <code>run</code> in step 1.</li> <li><code>(GFX.MainWindow)</code> creates the application window.</li> </ol> <p></p>"},{"location":"snake/steps/step-2/#adding-ui","title":"Adding UI","text":"<p>We will render the game using UI elements. We need to initialize some code to get the UI working.</p> EDNResult <ol> <li>Boilerplate code to initialize some stuff required for rendering the UI.</li> <li><code>(UI)</code> defines a UI context.</li> <li>UI code will go here.</li> <li>Actual render of the UI.</li> </ol> <p></p>"},{"location":"snake/steps/step-2/#lets-try-it-out","title":"Let's try it out!","text":"<p>Let's give our function a try. First, we will change a few values in the grid to be something other than <code>0</code>. And then we will try to retrieve and display those values in our brand-new window. Can you guess which values will be displayed?</p> EDNResult <pre><code>(def grid-cols 5)\n(def grid-rows 4)\n(def grid\n[0 2 0 0 3\n1 0 7 0 0\n0 0 0 4 0\n6 0 5 0 8])\n\n(defn get-index []\n(-&gt; (| (Take 0) &gt;= .x)\n(| (Take 1) &gt;= .y)\n.y (Math.Multiply grid-cols) (Math.Add .x)))\n\n(defloop main-wire\n(GFX.MainWindow\n:Title \"Snake game\" :Width 480 :Height 360\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(UI.CentralPanel\n(-&gt;\n(int2 0 1) (get-index) &gt;= .a\n(int2 3 2) (get-index) &gt;= .b\n\ngrid (Take .a) (ToString) (UI.Label)\ngrid (Take .b) (ToString) (UI.Label))))\n\n(GFX.Render :Steps .render-steps))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <p></p> <p> </p>"},{"location":"snake/steps/step-3/","title":"Step 3","text":""},{"location":"snake/steps/step-3/#drawing-the-grid-the-fruit-and-the-snake","title":"Drawing the grid, the fruit, and the snake","text":"<p>We will assign some values to define what entity each cell of our grid can represent. For now, we will map these numeric values to draw a unique single character each as the visual representation.</p> value entity character 0 empty <code>\".\"</code> 1 fruit <code>\"F\"</code> 2 head <code>\"H\"</code> 3 body <code>\"B\"</code> 4 tail <code>\"T\"</code> <p>A snake has a head and a tail, and a body. We can represent these entities as a sequence of coordinates. The first element is the tail, the last one is the head, and everything in between is the body.</p> EDN <pre><code>[(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\n</code></pre> <p>The fruit, however, occupies a single cell - so we just need one set of coordinates.</p> <p>Every other cell is empty (or unoccupied) and is represented with a \u2018.\u2019.</p> EDN <pre><code>(int2 4 4) &gt;= .fruit\n</code></pre> <p>To position the cells, we will use a <code>(UI.Area)</code>. By default, it is anchored at the top left corner, which means the position at that corner is <code>(float2 0 0)</code>.</p> <p>To calculate the position of our cell, we take into account the number of columns, the size in pixels we want our cell to have (<code>cell-size</code>) and additional <code>x-offset</code> and <code>y-offset</code> so that the overall grid is not stuck at the top left corner but slightly moved right and down.</p> EDN <pre><code>(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cell [n] ;; (1)\n(| (int2 ;; (2)\n(% n grid-cols) ;; (3)\n(/ n grid-cols)) ;; (4)\n(ToFloat2) ;; (5)\n(Math.Multiply (float2 cell-size)) ;; (6)\n(Math.Add (float2 x-offset y-offset)) &gt; .position) ;; (7)\n(| (Take n) ;; (8)\n(UI.Area\n:Position .position\n:Contents\n(-&gt; (Match ;; (9)\n[0 (-&gt; \".\") ; empty\n1 (-&gt; \"F\") ; fruit\n2 (-&gt; \"H\") ; head\n3 (-&gt; \"B\") ; body\n4 (-&gt; \"T\") ; tail\n]false)\n(UI.Label))))) ;; (10)\n</code></pre> <ol> <li>The input of this function will be our grid. The parameter <code>n</code> is the cell index we want to render.</li> <li>We want to apply mathematical functions to integral numbers (so-called integers) so we explicitly use the <code>(int2)</code>type.</li> <li><code>%</code> is the modulo function. We use it to get the <code>x</code> coordinate, i.e. the index of the column in our grid.</li> <li><code>/</code> is the division function. We use it to get the <code>y</code> coordinate, i.e. the index of the row in our grid.</li> <li><code>(UI.Area)</code> requires a <code>(float2)</code> type for its <code>:Position</code> parameter, so we do a conversion using <code>(ToFloat2)</code></li> <li>We defined the size for a single cell to be <code>cell-size</code>. Without it, it would have been a 1x1 pixel which we could hardly see.</li> <li>Finally, we add the offsets so that our grid is more centered. The final value is saved into the <code>.position</code> variable.</li> <li>Now, we get the value of <code>n</code>-indexed cell from the <code>.grid</code> variable that was given as input to the <code>render-area</code> function.</li> <li>In that action, we <code>(Match)</code> the value of the cell to the corresponding character we have chosen.</li> <li>Then the matched character is displayed in place of that grid element using <code>(UI.Label)</code>.</li> </ol> <p>The above function only deals with a single cell. We want to render all cells. To do so we will slightly modify it to recursively apply to each cell index (from <code>0</code> to <code>(- (* grid-cols grid-rows) 1)</code>, i.e. the number of columns times the number of rows, minus 1 because we start our index at <code>0</code>).</p> EDN <pre><code>(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n] ;; (1)\n(if\n(= n -1) ;; (2)\nnil  ;; (3)\n(-&gt; ;; (4)\n(| (int2\n(% n grid-cols)\n(/ n grid-cols))\n(ToFloat2)\n(Math.Multiply (float2 cell-size))\n(Math.Add (float2 x-offset y-offset)) &gt; .position)\n(| (Take n)\n(UI.Area\n:Position .position\n:Contents\n(-&gt; (Match\n[0 (-&gt; \".\") ; empty\n1 (-&gt; \"F\") ; fruit\n2 (-&gt; \"H\") ; head\n3 (-&gt; \"B\") ; body\n4 (-&gt; \"T\") ; tail\n]false)\n(UI.Label))))\n(render-cells (- n 1))))) ;; (5)\n</code></pre> <ol> <li>We pluralized the function since it now renders several cells.</li> <li>We test whether <code>n</code> equals <code>-1</code>. Since we want to render cells from <code>0</code> to <code>(- (* grid-cols grid-rows) 1)</code>, this is our stopping condition.</li> <li>If we are in that case, we do nothing (<code>nil</code>).</li> <li>Otherwise, we perform the same code as we did above.</li> <li>Finally we do the recursion, which is just calling the same <code>render-cells</code> function but with a decremented value for <code>n</code>.</li> </ol>"},{"location":"snake/steps/step-3/#populating-the-grid","title":"Populating the grid","text":"<p>Before we can draw anything we need to update the grid with the fruit and the snake. To update a sequence at a given index, we can use the <code>(Assoc)</code> shard. And since the snake is saved as a sequence itself, we need to iterate through all its elements. However, the head, tail, and body are represented by different values, so we will handle them separately.</p> EDN <pre><code>(defshards populate-grid [fruit snake]\n; saves the input into a variable\n&gt;= .tmp-grid\n\n; first the snake tail and body\nsnake (Take 0) (get-index) &gt;= .tail-index ;; (1)\n[.tail-index 4] (Assoc .tmp-grid) ;; (2)\nsnake (Slice 1 -1) ;; (3)\n(ForEach\n(-&gt; (get-index) &gt;= .limb-index\n[.limb-index 3] (Assoc .tmp-grid)))\n\n; then the fruit\nfruit (get-index) &gt;= .fruit-index\n[.fruit-index 1] (Assoc .tmp-grid)\n\n; finally the snake head\nsnake (RTake 0) (get-index) &gt;= .head-index ;; (4)\n[.head-index 2] (Assoc .tmp-grid)\n\n; return the populated grid\n.tmp-grid)\n</code></pre> <ol> <li>We have already seen <code>(Take)</code> and <code>get-index</code> in step 2.</li> <li>Assoc lets us update the sequence.</li> <li><code>(Slice)</code> gives a part of a sequence in a range. <code>1</code> means we start at the second element of the sequence (in other words, we skip <code>1</code> element), and <code>-1</code> means we stop at one element before the last (in other words, we skip <code>1</code> element from the end).</li> <li><code>(RTake)</code> is similar to <code>(Take)</code>, except it starts from the end of the sequence instead of the beginning (i.e. \"reverse take\").</li> </ol> <p>This new function <code>populate-grid</code> will take our empty grid as input and return a populated grid. That is why we need a temporary variable inside the function (<code>.tmp-grid</code>).</p> Note <p>Another alternative would have been, to have a single grid and erase the previous positions of the fruit and the snake before updating to their new positions. We find it easier to just update the whole grid at once for this tutorial.</p>"},{"location":"snake/steps/step-3/#lets-try-it-out","title":"Let's try it out!","text":"<p>Let's put into practice all that we have seen so far.</p> EDNResult <pre><code>(def grid-cols 12)\n(def grid-rows 10)\n(def empty-grid\n[0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0])\n\n(defshards get-index []\n(| (Take 0) &gt;= .x)\n(| (Take 1) &gt;= .y)\n.y (Math.Multiply grid-cols) (Math.Add .x))\n\n(defshards populate-grid [fruit snake]\n; saves the input into a variable\n&gt;= .tmp-grid\n\n; first the snake tail and body\nsnake (Take 0) (get-index) &gt;= .tail-index\n[.tail-index 4] (Assoc .tmp-grid)\nsnake (Slice 1 -1)\n(ForEach\n(-&gt; (get-index) &gt;= .limb-index\n[.limb-index 3] (Assoc .tmp-grid)))\n\n; then the fruit\nfruit (get-index) &gt;= .fruit-index\n[.fruit-index 1] (Assoc .tmp-grid)\n\n; finally the snake head\nsnake (RTake 0) (get-index) &gt;= .head-index\n[.head-index 2] (Assoc .tmp-grid)\n\n; return the populated grid\n.tmp-grid)\n\n(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n]\n(if\n(= n -1)\nnil\n(-&gt;\n(| (int2\n(% n grid-cols)\n(/ n grid-cols))\n(ToFloat2)\n(Math.Multiply (float2 cell-size))\n(Math.Add (float2 x-offset y-offset)) &gt; .position)\n(| (Take n)\n(UI.Area\n:Position .position\n:Contents\n(-&gt; (Match\n[0 (-&gt; \".\") ; empty\n1 (-&gt; \"F\") ; fruit\n2 (-&gt; \"H\") ; head\n3 (-&gt; \"B\") ; body\n4 (-&gt; \"T\") ; tail\n]false)\n(UI.Label))))\n(render-cells (- n 1)))))\n\n(defloop main-wire\n; logic\n[(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\n(int2 6 7) &gt;= .fruit\nempty-grid (populate-grid .fruit .snake) &gt;= .grid\n; window\n(GFX.MainWindow\n:Title \"Snake game\" :Width 480 :Height 360\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n.grid\n(Setup (float2 0) &gt;= .position)\n(render-cells (- (* grid-cols grid-rows) 1))))\n\n(GFX.Render :Steps .render-steps))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <p></p> <p> </p>"},{"location":"snake/steps/step-4/","title":"Step 4","text":""},{"location":"snake/steps/step-4/#moving-the-fruit","title":"Moving the fruit","text":"<p>When the snake eats a fruit we will need another unoccupied location for the new fruit.</p> <p>Let's first compute the list of locations that are unoccupied.</p> EDN <pre><code>(defshards get-free-locations [snake fruit]\n[] &gt;= .locations ;; (1)\n(ForRange ;; (2)\n:From 0 :To (- grid-cols 1) :Action ;; (3)\n(-&gt; &gt;= .a\n(ForRange\n:From 0 :To (- grid-rows 1) :Action\n(-&gt; &gt;= .b\n[.a .b] (ToInt2) &gt;= .location\n(When (-&gt; snake (IndexOf .location) (Is -1) (And) fruit (IsNot .location)) ;; (4) (5) (6)\n(-&gt; .location (Push .locations))))))) ;; (7)\n.locations)\n</code></pre> <ol> <li><code>[]</code> is an empty sequence.</li> <li><code>(ForRange)</code> iterates a range of values (including both <code>:From</code> and <code>:To</code> ends).</li> <li><code>(- a b)</code> is a built-in function that can act on constant values (as opposed to <code>(Math.Subtract)</code> that can act on constants and variables).</li> <li><code>(When)</code> is similar to <code>(If)</code>, except it is \"passthrough\" by default (don't worry about that concept for now).</li> <li><code>(Is)</code> and <code>(IsNot)</code> compare two values.</li> <li><code>(And)</code> is a logic operator.</li> <li><code>(Push)</code> adds a value to a sequence.</li> </ol> <p>The function takes the positions of the snake body (incl. head and tail) and the current fruit position. It then iterates through all possible coordinates skipping the ones that are either occupied by the snake or the current fruit. The sequence of potential locations is then returned as the function's output.</p> <p>Now all we need to do is select a random position from this sequence and that will be our next fruit position.</p> EDN <pre><code>(defshards move-fruit [fruit snake]\n(get-free-locations fruit snake) &gt;= .free-loc\n(Count .free-loc) &gt;= .max ;; (1)\n(RandomInt .max) &gt;= .next-fruit-loc ;; (2)\n.free-loc (Take .next-fruit-loc) (ToInt2)) ;; (3) (4)\n</code></pre> <ol> <li><code>(Count)</code> returns the number of elements in a sequence.</li> <li><code>(RandomInt)</code> returns a random value between 0 and the given maximum (exclusive).</li> <li>We have already seen <code>(Take)</code> in step 2.</li> <li><code>(ToInt2)</code> ensures that we return an <code>int2</code> value.</li> </ol>"},{"location":"snake/steps/step-4/#moving-the-snake","title":"Moving the snake","text":"<p>In the snake game, the snake moves by one cell either horizontally or vertically. We could \"move\" every cell of its body one by one, but there is a clever trick we can use: we can just remove the first element (tail) from the snake's sequence and add one for the new head position.</p> <p>When the snake is growing (after eating a fruit) we only add the new head (in place of the fruit element) but keep the tail such that snake seems to grow in the direction of the fruit it just ate.</p> EDN <pre><code>(defshards move-snake [snake offset grow]\nsnake (RTake 0) (Math.Add offset) (Push snake) ;; (1)\n(WhenNot (-&gt; grow) (DropFront snake))) ;; (2) (3)\n</code></pre> <ol> <li>We have already seen <code>(RTake)</code> in step 3.</li> <li><code>(WhenNot)</code> is similar to <code>(When)</code> but with the opposite logic.</li> <li><code>(DropFront)</code> removes the first element of a sequence.</li> </ol> <p>Now we need the snake to move at regular intervals in the direction chosen by the player.</p> <p>Let's first listen to the player's input. We will use the keyboard's arrow keys (up, down, left, right) for this.</p> EDN <pre><code>(Inputs.KeyDown \"up\" (-&gt; \"up\" &gt; .direction)) ;; (1)\n(Inputs.KeyDown \"right\" (-&gt; \"right\" &gt; .direction))\n(Inputs.KeyDown \"down\" (-&gt; \"down\" &gt; .direction))\n(Inputs.KeyDown \"left\" (-&gt; \"left\" &gt; .direction))\n</code></pre> <ol> <li><code>(Inputs.KeyDown)</code> executes an action when a key is down. It has a sibling event: <code>(Inputs.KeyUp)</code>. <code>(&gt;)</code> is an alias for <code>Push</code>.</li> </ol> <p>We also want to prevent the player from accidentally selecting the opposite direction (e.g. down while the snake is going up) since that would immediately end the game (as the snake would immediately turn backward to eat its own body starting with its neck). One easy way to do this is to compare the newly chosen direction with the previous one.</p> EDN <pre><code>(Inputs.KeyDown\n\"up\"\n(When (-&gt; .prev-direction (IsNot \"down\"))\n(-&gt; \"up\" &gt; .direction)))\n(Inputs.KeyDown\n\"right\"\n(When (-&gt; .prev-direction (IsNot \"left\"))\n(-&gt; \"right\" &gt; .direction)))\n(Inputs.KeyDown\n\"down\"\n(When (-&gt; .prev-direction (IsNot \"up\"))\n(-&gt; \"down\" &gt; .direction)))\n(Inputs.KeyDown\n\"left\"\n(When (-&gt; .prev-direction (IsNot \"right\"))\n(-&gt; \"left\" &gt; .direction)))\n</code></pre> <p>Finally, the snake will move at regular intervals. We can do that by comparing the current time and the time since the last update.</p> EDN <pre><code> (When (-&gt; (Time.Now) (Math.Subtract .last-tick) (IsMoreEqual 0.50)) ;; (1)\n(-&gt; (Time.Now) &gt; .last-tick\n; move the snake\n.direction (Match [\"up\" (move-snake .snake (int2 0 -1) .grow)\n\"right\" (move-snake .snake (int2 1 0) .grow)\n\"down\" (move-snake .snake (int2 0 1) .grow)\n\"left\" (move-snake .snake (int2 -1 0) .grow)])))\n</code></pre> <ol> <li><code>(Time.Now)</code> returns the time elapsed since the start of the game.</li> </ol> <p>Now the snake will move every half a second. We could change this value to vary the difficulty of the game.</p>"},{"location":"snake/steps/step-4/#lets-try-it-out","title":"Let's try it out!","text":"<p>Putting together all that we have seen so far, and adding a bit of initialization (that we conveniently put in its function to allow us to reinitialize the game if the player hits the space bar), we have the following code.</p> EDNResult <pre><code>(def grid-cols 12)\n(def grid-rows 10)\n(def empty-grid\n[0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0 0 0])\n\n(defshards get-index []\n(| (Take 0) &gt;= .x)\n(| (Take 1) &gt;= .y)\n.y (Math.Multiply grid-cols) (Math.Add .x))\n\n(defshards get-free-locations [fruit snake]\n[] &gt;= .locations\n(ForRange\n:From 0 :To (- grid-cols 1) :Action\n(-&gt; &gt;= .a\n(ForRange\n:From 0 :To (- grid-rows 1) :Action\n(-&gt; &gt;= .b\n[.a .b] (ToInt2) &gt;= .location\n(When (-&gt; snake (IndexOf .location) (Is -1) (And) fruit (IsNot .location))\n(-&gt; .location (Push .locations)))))))\n.locations)\n\n(defshards move-fruit [fruit snake]\n(get-free-locations fruit snake) &gt;= .free-loc\n(Count .free-loc) &gt;= .max\n(RandomInt .max) &gt;= .next-fruit-loc\n.free-loc (Take .next-fruit-loc) (ToInt2))\n\n(defshards move-snake [snake offset grow]\nsnake (RTake 0) (Math.Add offset) (Push snake)\n(WhenNot (-&gt; grow) (DropFront snake)))\n\n(defshards populate-grid [fruit snake]\n&gt;= .tmp-grid\n\n; first the snake tail and body\nsnake (Take 0) (get-index) &gt;= .tail-index\n[.tail-index 4] (Assoc .tmp-grid)\nsnake (Slice 1 -1)\n(ForEach\n(-&gt; (get-index) &gt;= .limb-index\n[.limb-index 3] (Assoc .tmp-grid)))\n\n; then the fruit\nfruit (get-index) &gt;= .fruit-index\n[.fruit-index 1] (Assoc .tmp-grid)\n\n; finally the snake head\nsnake (RTake 0) (get-index) &gt;= .head-index\n[.head-index 2] (Assoc .tmp-grid)\n\n; return the populated grid\n.tmp-grid)\n\n(def cell-size 18)\n(def x-offset 48)\n(def y-offset 36)\n(defn render-cells [n]\n(if\n(= n -1)\nnil\n(-&gt;\n(| (int2\n(% n grid-cols)\n(/ n grid-cols))\n(ToFloat2)\n(Math.Multiply (float2 cell-size))\n(Math.Add (float2 x-offset y-offset)) &gt; .position)\n(| (Take n)\n(UI.Area\n:Position .position\n:Contents\n(-&gt; (Match\n[0 (-&gt; \".\") ; empty\n1 (-&gt; \"F\") ; fruit\n2 (-&gt; \"H\") ; head\n3 (-&gt; \"B\") ; body\n4 (-&gt; \"T\") ; tail\n]false)\n(UI.Label))))\n(render-cells (- n 1)))))\n\n(defshards initialize []\n[(int2 1 2) (int2 2 2) (int2 3 2) (int2 3 3) (int2 4 3)] &gt;= .snake\nfalse &gt;= .grow\n(move-fruit (int2 0 0) .snake) &gt;= .fruit\n\"right\" &gt;= .direction &gt;= .prev-direction\n(Time.Now) &gt;= .last-tick\n; do it once to not wait the next tick\nempty-grid (populate-grid .fruit .snake) &gt;= .grid)\n\n(defloop main-wire\n(Once (initialize))\n; logic\n(When (-&gt; (Time.Now) (Math.Subtract .last-tick) (IsMoreEqual 0.33))\n(-&gt; (Time.Now) &gt; .last-tick\n; move the snake\n.direction (Match [\"up\" (move-snake .snake (int2 0 -1) .grow)\n\"right\" (move-snake .snake (int2 1 0) .grow)\n\"down\" (move-snake .snake (int2 0 1) .grow)\n\"left\" (move-snake .snake (int2 -1 0) .grow)])\n.snake (RTake 0) &gt;= .head\n; did the snake eat the fruit?\n(If (-&gt; .head (Is .fruit))\n(-&gt; true &gt; .grow\n(move-fruit .fruit .snake) &gt; .fruit)\n(-&gt; false &gt; .grow)\n:Passthrough true)\n; update\nempty-grid (populate-grid .fruit .snake) &gt; .grid\n.direction &gt; .prev-direction))\n; window\n(GFX.MainWindow\n:Title \"Snake game\" :Width 480 :Height 360\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n.ui-draw-queue (GFX.ClearQueue)\n\n(UI\n.ui-draw-queue\n(-&gt;\n.grid\n(Setup (float2 0) &gt;= .position)\n(render-cells (- (* grid-cols grid-rows) 1))))\n\n(GFX.Render :Steps .render-steps)\n\n(Inputs.KeyDown\n\"up\"\n(When (-&gt; .prev-direction (IsNot \"down\"))\n(-&gt; \"up\" &gt; .direction)))\n(Inputs.KeyDown\n\"right\"\n(When (-&gt; .prev-direction (IsNot \"left\"))\n(-&gt; \"right\" &gt; .direction)))\n(Inputs.KeyDown\n\"down\"\n(When (-&gt; .prev-direction (IsNot \"up\"))\n(-&gt; \"down\" &gt; .direction)))\n(Inputs.KeyDown\n\"left\"\n(When (-&gt; .prev-direction (IsNot \"right\"))\n(-&gt; \"left\" &gt; .direction)))\n(Inputs.KeyDown\n\"space\" (initialize)))))\n\n(defmesh root)\n(schedule root main-wire)\n(run root (/ 1.0 60))\n</code></pre> <p></p> Note <p><code>(Once)</code> is executed only once and thus is not repeated every frame.</p> <p> </p>"},{"location":"snake/steps/step-5/","title":"Step 5","text":""},{"location":"snake/steps/step-5/#wall-collision-and-game-over-conditions","title":"Wall collision and game over conditions","text":"<p>If the snake hits a wall, the game ends. Similarly, if the snake tries to eat a part of its own body, the game still ends.</p> <p>Remember that we have a sequence that represents the whole snake body. The last element of that sequence is the head.</p> <p>To test whether the snake is going outside the bounds of the play space, we just need to compare the <code>x</code> (first coordinate) and <code>y</code> (second coordinate) of the head with the number of columns and rows respectively. If this x or y value is greater than the maximum column or row value respectively, then the snake has breached the grid walls. </p> <p>We need to do this before attempting to render as otherwise the computed render position could go out of bounds and produce an error (and since we are not yet handling this error the game would crash). We will use a boolean value (<code>true</code> or <code>false</code>) to mark when the game is over and avoid updating the grid in such a case.</p> EDN <pre><code>; get the head coordinates\n.snake (RTake 0) &gt;= .head\n\n; snake hits a wall?\n(When (-&gt; .head (Take 0) (IsLess 0) (Or) (Take 0) (IsMoreEqual grid-cols)\n(Or)\n.head (Take 1) (IsLess 0) (Or) (Take 1) (IsMoreEqual grid-rows))\n(-&gt; true &gt; .game-over))\n</code></pre> <p>To check whether the snake is eating its own body, we use the fact that the head is the last element of the snake sequence. If we find another body cell that has the same coordinates while having a different index in the sequence, it means that we have an overlap and the poor snake is in pain.</p> EDN <pre><code>; get the index of the head (which is count - 1)\n(Count .snake) (Math.Subtract 1) &gt;= .head-idx\n\n; snake eats its own body?\n(When (-&gt; .snake (IndexOf .head) (IsNot .head-idx))\n(-&gt; true &gt; .game-over))\n</code></pre>"},{"location":"snake/steps/step-5/#a-few-graphical-changes","title":"A few graphical changes","text":"<p>Now that have conditions to end the game, we can add a bit more logic to display the final score (which in our case will be the length of the snake).</p> EDN <pre><code>(UI.BottomPanel\n:Contents\n(-&gt;\n(When (-&gt; .game-over)\n(UI.Horizontal\n(-&gt; \"GAME OVER!\" (UI.Label :Style {:color (color 255 0 0)}) ;; (1)\n(UI.Space 10.0)\n\"Final score: \" (UI.Label)\n(Count .snake) (ToString) (UI.Label))))))\n</code></pre> <ol> <li><code>:Style</code> is an optional parameter for <code>(UI.Label)</code>. It lets specify the color of the dsiplay text using <code>(color)</code> (which is a built-in type that represents an RGBA color, where each component is a value in the <code>[0, 255]</code> range.)</li> </ol> <p>We will also add a small menu, to enable the player to cleanly restart or exit the game.</p> EDN <pre><code>(defshards menus []\n(UI.MenuBar\n(-&gt;\n(UI.Menu ;; (1)\n\"File\"\n(-&gt;\n(UI.Button \"New game\" (-&gt; (initialize) (UI.CloseMenu)))\n(UI.Separator)\n(UI.Button \"Quit\" (Stop)))))))\n</code></pre> <ol> <li><code>(UI.Menu)</code> contains one or more <code>(UI.Button)</code> and is hosted in a <code>(UI.MenuBar)</code>.</li> </ol> <p>To display the menu we need to add it to a <code>(UI.TopPanel)</code>.</p> EDN <pre><code>(UI.TopPanel :Contents (menus))\n</code></pre> <p>That's it! Congratulations on completing the snake tutorial.</p> <p>The complete code is available in the full game section.</p> <p> </p>"},{"location":"yes-no-game/","title":"Yes-No Game Tutorial","text":"<p>Welcome! In this tutorial, we will be creating a simple game of reflexes using Shards.</p> <p>This tutorial assumes that you have a basic understanding of Shards. In order to run the code examples used here, you are required to have Shards built. </p> <p>For more information, check out the following links on:</p> <ol> <li> <p>The Basics of Shards</p> </li> <li> <p>Building Shards</p> </li> <li> <p>Running Shards</p> </li> </ol> <p>Here are the key concepts that we will be covering in this tutorial:</p> <ol> <li> <p>How to create UI and receive User Input</p> </li> <li> <p>How to create variance with Random</p> </li> <li> <p>How to run a Timer</p> </li> <li> <p>How to set up a basic game loop</p> </li> </ol> <p>You can either follow the step-by-step guide, or jump directly to the full game.</p> <ul> <li> <p>Introduction</p> </li> <li> <p>Step by step</p> </li> <li> <p>Full game</p> </li> </ul> <p> </p>"},{"location":"yes-no-game/introduction/","title":"Introduction","text":""},{"location":"yes-no-game/introduction/#gameplay","title":"Gameplay","text":"<p>In this game, the player will be shown 2 images. They will have 5 seconds to decide whether the animals shown are the same, or different. The player will have to press the \u2191 directional key to answer \"Yes\", and the \u2193 directional key to answer \"No\". There will be a total of 10 rounds, and the player's total score is tabulated and shown at the end. If the 5s timer runs out, no score is given for the round and the next round is started.</p> <p> </p>"},{"location":"yes-no-game/full-game/","title":"Full game","text":"EDN yesnogame.edn<pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n(LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n(defshards initialize-variables []\n;; Variables to reset each round \ntrue &gt;= .new-round\nmax-timer &gt;= .time-remaining\nfalse &gt;= .input-received\n\n;; Variables to reset each game \n0 &gt;= .total-score\n1 &gt;= .current-round\nfalse &gt;= .game-over\n\n;; Other Shared Variables\n0 &gt;= .left-image-index\n0 &gt;= .right-image-index\n(Count .images) &gt;= .total-images\ntrue &gt;= .same-image)\n\n(defshards reset-round-variables []\nfalse &gt; .new-round\nmax-timer &gt; .time-remaining\nfalse &gt; .input-received)\n\n(defshards reset-game-variables []\n(reset-round-variables)\n0 &gt; .total-score\n1 &gt; .current-round\nfalse &gt; .game-over)\n\n(defshards initialize-round []\n(RandomInt :Max .total-images) &gt; .left-image-index\n(RandomInt :Max .total-images) &gt; .right-image-index\n\n(If\n:Predicate (-&gt; .left-image-index (Is .right-image-index))\n:Then (-&gt; true &gt; .same-image)\n:Else (-&gt; false &gt; .same-image))\n\n(reset-round-variables))\n\n(defwire end-round\n(Setup 0 &gt;= .new-round-number)\n\n.current-round (Math.Add 1)\n&gt; .new-round-number\n\n(If\n:Predicate\n(-&gt; .new-round-number (IsMore total-rounds))\n:Then\n(-&gt; true &gt; .game-over)\n:Else\n(-&gt;\n.new-round-number &gt; .current-round\ntrue &gt; .new-round)))\n\n(defshards check-answer [yes-input]\n(When\n:Predicate (-&gt; .input-received (Is false))\n:Action\n(-&gt;\n(When\n:Predicate (-&gt; .same-image (Is yes-input))\n:Action (-&gt; (Math.Inc .total-score)))\n\ntrue &gt; .input-received\n(When\n:Predicate (-&gt; .game-over (IsNot true))\n:Action (-&gt; nil (Step end-round))))))\n\n(defshards timer-tick []\n(When\n:Predicate (-&gt; .game-over (Is false))\n:Action\n(-&gt;\n(Math.Dec .time-remaining)\n(When\n:Predicate (-&gt; .time-remaining (IsLess 0))\n:Action (-&gt; nil (Step end-round))))))\n\n(defshards main-game-ui []\n(UI.BottomPanel\n:Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n(UI.TopPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Score: \" (UI.Label)\n.total-score (ToString) (UI.Label)\n(UI.Separator)\n\"Round: \" (UI.Label)\n.current-round (ToString) (UI.Label)\n(UI.Separator)\n\"Time Left: \" (UI.Label)\n.time-remaining (ToString) (UI.Label)))))\n\n(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n(UI.Area\n:Position (float2 -250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take .left-image-index) (UI.Image)))\n(UI.Area\n:Position (float2 250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take .right-image-index) (UI.Image))))))))\n\n(defshards game-over-ui []\n(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Area\n:Position (float2 0.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n\"GAME OVER\" (UI.Label)\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Final Score: \" (UI.Label)\n.total-score (ToString) (UI.Label)\n\"/\"  (UI.Label)\ntotal-rounds (ToString) (UI.Label)))\n\n(UI.Button\n:Label \"Play Again!\"\n:Action (-&gt; (reset-game-variables))))))))\n\n(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n:Width 1280 :Height 768\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n(| .ui-draw-queue (GFX.ClearQueue))\n\n(If\n:Predicate (-&gt; .game-over)\n:Then\n(-&gt; (UI .ui-draw-queue (game-over-ui)))\n:Else\n(-&gt; (UI .ui-draw-queue (main-game-ui))))\n\n(GFX.Render :Steps .render-steps)\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt; (check-answer true)))\n\n(Inputs.KeyDown\n:Key \"down\"\n:Action (-&gt; (check-answer false))))))\n\n(defloop logic-loop\n(Once\n:Action (-&gt; (timer-tick))\n:Every 1.0)\n\n(WhenNot\n:Predicate (-&gt; .game-over)\n:Action\n(-&gt;\n(When\n:Predicate (-&gt; .new-round)\n:Action (-&gt; (initialize-round))))))\n\n(defshards initialize-round []\n(RandomInt :Max .total-images) &gt; .left-image-index\n(RandomInt :Max .total-images) &gt; .right-image-index\n\n(If\n:Predicate (-&gt; .left-image-index (Is .right-image-index))\n:Then (-&gt; true &gt; .same-image)\n:Else (-&gt; false &gt; .same-image))\n\n(reset-round-variables))\n\n(defloop game-loop\n(Setup (load-resources) (initialize-variables))\n(Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre>"},{"location":"yes-no-game/steps/","title":"Steps","text":"<ul> <li>Step 1 - Setting up the Game Loop</li> <li>Step 2 - Drawing the Game UI</li> <li>Step 3 - Initializing each Round</li> <li>Step 4 - Adding Multiple Rounds</li> <li>Step 5 - Handling User Input</li> <li>Step 6 - Finishing Touches</li> </ul>"},{"location":"yes-no-game/steps/step-1/","title":"Step 1","text":"<p>This chapter will guide you on setting up the base of your game so that it can start running.</p>"},{"location":"yes-no-game/steps/step-1/#the-programs-base","title":"The Program's Base","text":"<p>A basic Shards program consists of:</p> <ul> <li> <p>Writing Shards and Wires</p> </li> <li> <p>Scheduling Wires onto a Mesh</p> </li> </ul> <p>To learn more about Wires, Meshes, and the overall flow of Shards, check out the primer here.</p> <p>A basic Shards program looks like this:</p> Code <pre><code>(defwire game-wire          ;; Define a Wire named \"game-wire\" (1)\n(Msg \"Hello World!\"))   ;; Insert stuff to run here (2)\n\n(defmesh main)              ;; Define a Mesh named \"main\" (3)\n(schedule main game-wire)   ;; Schedule the Wire on the Mesh (4)\n(run main)                  ;; Run the Mesh (5)\n</code></pre> <ol> <li><code>defwire</code> is a macro used to define a Wire.</li> <li><code>Msg</code> prints out the string passed into it.</li> <li><code>defmesh</code> is a macro used to define a Mesh.</li> <li><code>schedule</code> queues a Wire on the Mesh.</li> <li><code>run</code> executes Wires on the Mesh.</li> </ol> <p>For the program to run continuously, we will be using a looped Wire instead. This can be done by replacing <code>defwire</code> with <code>defloop</code>. You can then adjust the time interval between each loop by adding a second argument to <code>(run)</code>.</p> <p>Since most games run at 60 FPS (Frames per Second), we will be using <code>(/ 1.0 60.0)</code>  to get the time interval between each frame.</p> <p>Note</p> <p><code>(/ 1.0 60.0)</code> reads as \"1 divided by 60\".</p> Code <pre><code>(defloop game-loop          ;; Define a Looped Wire named \"game-loop\" (1)\n(Msg \"Hello World!\"))   ;; Insert stuff to run here \n\n(defmesh main)              ;; Define a Mesh named \"main\"\n(schedule main game-loop)   ;; Schedule the Loop on the Mesh\n(run main (/ 1.0 60.0))     ;; Run the Mesh\n</code></pre> <ol> <li><code>defloop</code> is a macro used to define a Loop.</li> </ol>"},{"location":"yes-no-game/steps/step-1/#game-loops","title":"Game Loops","text":"<p>To make a game, you will need:</p> <ul> <li> <p>Code to draw the UI (such as your game menus, text boxes, and images)</p> </li> <li> <p>Code to run the game's logic (such as calculating the score, determining when to end a round)</p> </li> </ul> <p>It might be quite disorderly if we did everything within a single <code>defloop</code>. </p> <p>To keep our code easily readable and organized, we split the UI and logic code into separate Loops running together on the Mesh. </p> <p>We can achieve this by employing the <code>Branch</code> shard and creating two separate loops for the game's logic and UI.</p> Branch <p><code>Branch</code> creates a mini-Mesh of sorts and schedules Wires to run on it.</p> Code <pre><code>(defloop ui-loop)                   ;; Insert UI code here\n(defloop logic-loop)                ;; Insert logic code here\n\n(defloop game-loop\n(Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre>"},{"location":"yes-no-game/steps/step-1/#the-setup-zone","title":"The Setup Zone","text":"<p>Most games will require code to ready the program, such as by loading resources and setting up variables to use. </p> <p>We can ready empty shards <code>load-resources</code> and <code>initialize-variables</code> to carry out these tasks. Place them in a <code>Setup</code> shard within the <code>game-loop</code> to ensure that they only run once.</p> Variables <p>Variables are containers that store values. You define a variable with a name, and assign a value to it. The value can then be retrieved by calling the variable with its assigned name.</p> Setup <p>The <code>Setup</code> shard will only be executed once, even within a Looped Wire. This makes it ideal to hold code that is only used once to ready the game. </p> Full Code <pre><code>(defshards load-resources [] nil)          ;; Load resources here (1)\n(defshards initialize-variables [] nil)    ;; Ready variables here\n(defloop ui-loop)                   ;; Insert UI code here\n(defloop logic-loop)                ;; Insert logic code here\n\n(defloop game-loop\n(Setup (load-resources)(initialize-variables)) ;; (2)\n(Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <ol> <li><code>defshards</code> allows multiple shards to be grouped together into a single shard. We will be placing shards that load resources into <code>load-resources</code> for example.</li> <li>The shards to load resources and initialize variables are only run once in the game loop</li> </ol> <p>The basic game loop is now ready!</p> <p>In the next chapter, we will learn about drawing the User Interface and adding graphics.</p> <p> </p>"},{"location":"yes-no-game/steps/step-2/","title":"Step 2","text":"<p>In this chapter, we will be adding graphics to your game. You will be able to create a game window and start seeing your game come to life.</p>"},{"location":"yes-no-game/steps/step-2/#the-ui-template","title":"The UI Template","text":"<p>To start drawing the UI in shards, we will have to ready the GFX window which serves as the base for our UI operations. It follows a fixed template that should be placed within our <code>ui-loop</code>.</p> UI Template <pre><code>(defshards main-game-ui [] nil)     ;; Add your UI shards here\n\n(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n:Width 1280 :Height 768\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n(| .ui-draw-queue (GFX.ClearQueue))\n(UI .ui-draw-queue (main-game-ui))\n(GFX.Render :Steps .render-steps))))\n</code></pre> What does the GFX code mean? <p>How the GFX window works is beyond the scope of this tutorial. The rough idea is that we are giving instructions to the computer on what to draw to the screen. For more information, check out the documentation on the UI class.</p>"},{"location":"yes-no-game/steps/step-2/#planning-the-ui","title":"Planning the UI","text":"<p>Before writing code for the UI, it is good to have a design in mind. For this tutorial, we have prepared a simple design to follow:</p> <p></p> <p>With a design plan, it will be easier to identify the elements that will make up your UI. You can then implement the appropriate shards to draw them.</p> <p></p>"},{"location":"yes-no-game/steps/step-2/#the-bottom-panel","title":"The Bottom Panel","text":"<p>Let us start with the simplest panel, the Bottom Panel with a single Label. </p> <p>We will pass a string of instructions into the <code>UI.Label</code> shard, which we then pass into the Bottom Panel shard as its content.</p> Code <pre><code>(UI.BottomPanel ;; (1)\n:Contents\n(-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\"\n(UI.Label) ;; (2)\n))\n</code></pre> <ol> <li><code>UI.BottomPanel</code> is a UI element to hold other UI elements within it. It starts from the bottom of the Window.</li> <li><code>UI.Label</code> is a UI element to hold text.</li> </ol>"},{"location":"yes-no-game/steps/step-2/#the-top-panel","title":"The Top Panel","text":"<p>The Top Panel consists of a sequence of Labels and Separators in a Horizontal Group so that they are naturally aligned from left to right.</p> Code <pre><code>(UI.TopPanel ;; (1)\n:Contents\n(-&gt;\n(UI.Horizontal ;; (2)\n:Contents\n(-&gt;\n\"Score: 0\" (UI.Label)\n(UI.Separator) ;; (3)\n\"Round: 1\" (UI.Label)\n(UI.Separator)\n\"Time Left: 5\" (UI.Label)))))\n</code></pre> <ol> <li><code>UI.TopPanel</code> is a UI element to hold other UI elements within it. It starts from the top of the Window.</li> <li><code>UI.Horizontal</code> is a UI element to hold other UI elements within it. It aligns its elements horizontally, from left to right.</li> <li><code>UI.Separator</code> is a UI element that appears as a horizontal line within a vertical layout, and appears as a vertical line within a horizontal layout.</li> </ol> <p>We want to be able to change the values used for Score, the Round Number, and Time Left (they can't remain static after all!).</p> <p>This is where variables come in. We will be defining our variables in the <code>initialize-variables</code> shard created earlier.</p> <p>Define the following variables: </p> <ul> <li> <p><code>.total-score</code></p> </li> <li> <p><code>.current-round</code></p> </li> <li> <p><code>.time-remaining</code></p> </li> </ul> <p>Some values will remain the same throughout the game - these are known as constants. </p> <p>Define the following constants:</p> <ul> <li> <p><code>total-rounds</code></p> </li> <li> <p><code>max-timer</code></p> </li> </ul> Declaring Constants <p>Constants are values that cannot be changed. </p> <p>In Shards, you can declare named constants by using the macro <code>def</code>, which is used to give an alias to a value. Unnamed constants can be declared with <code>Const</code>.</p> Code <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards initialize-variables []\n0 &gt;= .total-score\n1 &gt;= .current-round\nmax-timer &gt;= .time-remaining)\n</code></pre> <p>We can now replace the fixed string numbers in our UI code with variables that will be updated as their values change.</p> Code <pre><code>(UI.TopPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Score: \" (UI.Label)\n.total-score (ToString) (UI.Label) ;; (1)\n(UI.Separator)\n\"Round: \" (UI.Label)\n.current-round (ToString) (UI.Label)\n(UI.Separator)\n\"Time Left: \" (UI.Label)\n.time-remaining (ToString) (UI.Label)))))\n</code></pre> <ol> <li><code>ToString</code> converts values into strings. In the code above, <code>UI.Label</code> expects a string input, which is why we have to convert the integer variables into strings.</li> </ol>"},{"location":"yes-no-game/steps/step-2/#the-central-panel","title":"The Central Panel","text":"<p>The central panel shows two images side by side. To draw the images onto the screen, we have to load them into our game's resources. We can do so in the <code>load-resources</code> shard created earlier. </p> <p>Create a folder named \"data\" at the directory where your game's script is located - we will be placing our images here.</p> <p>Note</p> <p>For this tutorial, we will be using 3 images of cats. You are free to choose the images of your own accord though!</p> <p>Our images have been standardized to have a length of 400 pixels for horizontal images. You can use an image editing tool to resize your images for consistency.</p> <p>Use the <code>Push</code> shard to push the images into a sequence.</p> Code <pre><code>(defshards load-resources []\n(LoadImage \"data/cats/cat01.png\") (Push :Name .images) ;; (1)(2)\n(LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n</code></pre> <ol> <li><code>LoadImage</code> is used to load images into your game's resources.</li> <li><code>Push</code> adds elements to the back of a sequence. It will create the sequence if it does not exist.</li> </ol> <p>We will randomize the images shown when tackling the logic of the game later. For now, let us display the first two images in the sequence as a placeholder.</p> <p>To better control where the images are drawn, we place each image in a <code>UI.Area</code> and specify its position.</p> Code <pre><code>(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n(UI.Area ;; (1)\n:Position (float2 -250.0, 0.0) ;; (2)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take 0) (UI.Image))) ;; (3)\n(UI.Area\n:Position (float2 250.0, 0.0) ;; (4) \n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take 1) (UI.Image)))))))\n</code></pre> <ol> <li><code>UI.Area</code> is a UI element that is used to place its contents at a specific position.</li> <li>Minus 250 pixels from the center on the x-axis</li> <li><code>Take</code> is used to retrieve the element stored at a specified index of a sequence.</li> <li>Add 250 pixels from the center on the x-axis</li> </ol> <p>Caution</p> <p>When using panels, ensure that <code>UI.CentralPanel</code> is always the last of the panels to be drawn to prevent errors.</p>"},{"location":"yes-no-game/steps/step-2/#outcome","title":"Outcome","text":"<p>The game's base UI is now ready! Try running the code to see your results.</p> <p>In the next chapter, we will delve into the game's logic and allow your program to ready itself for each game round.</p> <p>The code thus far:</p> Full CodeResult <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n(LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n(defshards initialize-variables []\n0 &gt;= .total-score\n1 &gt;= .current-round\nmax-timer &gt;= .time-remaining)\n\n(defshards main-game-ui []\n(UI.BottomPanel\n:Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n(UI.TopPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Score: \" (UI.Label)\n.total-score (ToString) (UI.Label)\n(UI.Separator)\n\"Round: \" (UI.Label)\n.current-round (ToString) (UI.Label)\n(UI.Separator)\n\"Time Left: \" (UI.Label)\n.time-remaining (ToString) (UI.Label)))))\n\n(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n(UI.Area\n:Position (float2 -250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take 0) (UI.Image)))\n(UI.Area\n:Position (float2 250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take 1) (UI.Image))))))))     (defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n:Width 1280 :Height 768\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n(| .ui-draw-queue (GFX.ClearQueue))\n(UI .ui-draw-queue (main-game-ui))\n(GFX.Render :Steps .render-steps))))\n\n(defloop logic-loop)\n\n(defloop game-loop\n(Setup (load-resources) (initialize-variables))\n(Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <p></p> <p> </p>"},{"location":"yes-no-game/steps/step-3/","title":"Step 3","text":"<p>In this chapter, we will be implementing logic that lets your program ready itself for a game round!</p>"},{"location":"yes-no-game/steps/step-3/#initializing-each-round","title":"Initializing each Round","text":"<p>Create a shard named <code>initialize-round</code>. We will be adding code to prepare each round here.</p> Code <pre><code>(defshards initialize-round [])\n</code></pre> <p>Place the new shard into the <code>logic-loop</code>. Wrap it within a <code>Setup</code> shard to ensure it only runs once (for now). We will add conditionals later that ensures <code>initialize-round</code> is only called when a new round should begin.</p> <p>Note</p> <p>Without placing <code>initialize-round</code> in <code>Setup</code>, it will be called constantly with each loop iteration. We do not want this! <code>initialize-round</code> should only be called at the start of each round.</p> Code <pre><code>(defloop logic-loop\n(Setup (initialize-round)))\n</code></pre>"},{"location":"yes-no-game/steps/step-3/#selecting-the-images","title":"Selecting the Images","text":"<p>We will use the <code>RandomInt</code> shard to randomly select an index from our <code>.image</code> sequence. The image stored at that index will be displayed in the game.</p> <p>Navigate to <code>initialize-variables</code>. </p> <p>Define the following variables to hold the randomly selected indices:</p> <ul> <li> <p><code>.left-image-index</code></p> </li> <li> <p><code>.right-image-index</code></p> </li> </ul> Code <pre><code>(defshards initialize-variables []\n0 &gt;= .left-image-index ;; (1)\n0 &gt;= .right-image-index ;; (2)\n\n0 &gt;= .total-score\n1 &gt;= .current-round\nmax-timer &gt;= .time-remaining)\n</code></pre> <ol> <li>The randomly selected index to use for the left image.</li> <li>The randomly selected index to use for the right image.</li> </ol> <p><code>RandomInt</code> requires the user to pass in the maximum number it can select up to. For example, <code>(RandomInt :Max 2)</code> will randomly choose a number from 0 to 1.</p> <p>Count the number of images in the <code>.images</code> sequence and store the value in a variable named <code>.total-images</code>. This value will be passed in as the <code>:Max</code> for <code>RandomInt</code>.</p> Code <pre><code>(defshards initialize-variables []\n0 &gt;= .left-image-index\n0 &gt;= .right-image-index\n(Count .images) &gt;= .total-images ;; (1)\n\n0 &gt;= .total-score\n1 &gt;= .current-round\nmax-timer &gt;= .time-remaining)\n</code></pre> <ol> <li><code>Count</code> will count the number of elements in a sequence. It can also count the number of characters in a string, or key-value pairs in a table.</li> </ol> <p>With <code>.total-images</code> as the upper limit for our random index range, we can now use <code>RandomInt</code> to determine our image indices. As the images chosen will change each round, we will select the images in the <code>initialize-round</code> shard.</p> Code <pre><code>(defshards initialize-round []\n(RandomInt :Max .total-images) &gt; .left-image-index ;; (1)(2)\n(RandomInt :Max .total-images) &gt; .right-image-index)\n</code></pre> <ol> <li>Randomly selects an index in the .image sequence.</li> <li><code>RandomInt</code> will randomly output a number from 0 to the number before the maximum value specified.</li> </ol> <p>Previously we used a placeholder to always show the first two images stored in <code>.images</code>. With the new logic implemented, we can update our UI code to display randomly selected images instead.</p> <p>Navigate to <code>UI.CentralPanel</code> in the <code>main-game-ui</code> shard.</p> <p>Replace:</p> Code <pre><code>.images (Take 0) (UI.Image)\n.images (Take 1) (UI.Image)\n</code></pre> <p>With:</p> Code <pre><code>.images (Take .left-image-index) (UI.Image) ;; (1)\n.images (Take .right-image-index) (UI.Image)\n</code></pre> <ol> <li>Retrieve the chosen image from the sequence</li> </ol>"},{"location":"yes-no-game/steps/step-3/#outcome","title":"Outcome","text":"<p>Congratulations! Your game can now display random images at the start of each round. </p> <p>Try running the code to see how the images change every time the game is run.</p> <p>In the next chapter, we will be adding multiple rounds to your game to increase its playability.</p> Full CodeResult <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n(LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n(defshards initialize-variables []\n0 &gt;= .left-image-index\n0 &gt;= .right-image-index\n(Count .images) &gt;= .total-images\n\n0 &gt;= .total-score\n1 &gt;= .current-round\nmax-timer &gt;= .time-remaining)\n\n(defshards initialize-round []\n.total-images\n(RandomInt :Max .total-images) &gt; .left-image-index (Log)\n(RandomInt :Max .total-images) &gt; .right-image-index (Log))\n\n(defshards main-game-ui []\n(UI.BottomPanel\n:Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n(UI.TopPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Score: \" (UI.Label)\n.total-score (ToString) (UI.Label)\n(UI.Separator)\n\"Round: \" (UI.Label)\n.current-round (ToString) (UI.Label)\n(UI.Separator)\n\"Time Left: \" (UI.Label)\n.time-remaining (ToString) (UI.Label)))))\n\n(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n(UI.Area\n:Position (float2 -250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take .left-image-index) (UI.Image)))\n(UI.Area\n:Position (float2 250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take .right-image-index) (UI.Image))))))))\n\n(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n:Width 1280 :Height 768\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n(| .ui-draw-queue (GFX.ClearQueue))\n(UI .ui-draw-queue (main-game-ui))\n(GFX.Render :Steps .render-steps))))\n\n(defloop logic-loop\n(Setup (initialize-round)))\n\n(defloop game-loop\n(Setup (load-resources) (initialize-variables))\n(Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <p> </p> <p> </p>"},{"location":"yes-no-game/steps/step-4/","title":"Step 4","text":"<p>Our game wouldn't be much fun if it ended in one round. To improve its playability, we implement multiple rounds.</p> <p>To implement multiple rounds, we will have to:</p> <ol> <li> <p>Add variables to track game states</p> </li> <li> <p>Implement shards to reset these variables</p> </li> </ol>"},{"location":"yes-no-game/steps/step-4/#adding-multiple-rounds","title":"Adding Multiple Rounds","text":"<p>For our game to be able to handle multiple rounds and an eventual \"Game Over\", we will need to manage game states.</p> <p>Let us define some variables to help keep track of the game states.  Navigate to <code>initialize-variables</code> and add in the following variables:</p> <ul> <li> <p><code>.new-round</code></p> </li> <li> <p><code>.game-over</code> </p> </li> </ul> <p>Organize your variables by grouping them according to when they will be reset. For example, some variables will be reset at the start of each round, while others are only reset when a new game is started.</p> Code <pre><code>(defshards initialize-variables []\n;; Variables to reset each round \ntrue &gt;= .new-round ;; (1)\nmax-timer &gt;= .time-remaining\n\n;; Variables to reset each game \n0 &gt;= .total-score\n1 &gt;= .current-round\nfalse &gt;= .game-over ;; (2)\n\n;; Other Shared Variables\n0 &gt;= .left-image-index\n0 &gt;= .right-image-index\n(Count .images) &gt;= .total-images\n)\n</code></pre> <ol> <li>Variable that tracks if a new round should be started.</li> <li>Variable that tracks if the game is over.</li> </ol> <p>Next, add code in the <code>logic-loop</code> to check if there should be a new round before executing <code>initialize-round</code>.</p> <p>Remove the <code>Setup</code> shard that was used to prevent the initialization code from running every Loop's iteration. We will be using conditionals instead.</p> Conditionals <p>Conditionals check if a given statement is true or false, and executes different code depending on the result. In the following code, the conditionals used are <code>WhenNot</code> and <code>When</code>.</p> BeforeAfter <pre><code>(defloop logic-loop\n(Setup (initialize-round)))\n</code></pre> <pre><code>(defloop logic-loop\n(WhenNot ;; (4)\n:Predicate (-&gt; .game-over) ;; (1)\n:Action\n(-&gt;\n(When ;; (5)\n:Predicate (-&gt; .new-round) ;; (2)\n:Action (-&gt; (initialize-round)))))) ;; (3) \n</code></pre> <ol> <li>If the game is not in a Game Over state...</li> <li>... and it is a new round,</li> <li>... initialize a new round.</li> <li><code>WhenNot</code> will only execute the <code>Action</code> specified when the <code>Predicate</code> is false. </li> <li><code>When</code> will only execute the <code>Action</code> specified when the <code>Predicate</code> is true. Unlike <code>If</code>, it does not have an <code>Else</code> parameter.    </li> </ol>"},{"location":"yes-no-game/steps/step-4/#handling-game-states","title":"Handling Game States","text":"<p>At the start of each round, we want to ensure that <code>.new-round</code> and <code>.time-remaining</code> are reset to their original values. Create the shard <code>reset-round-variables</code> to carry out this task.</p> Code <pre><code>(defshards reset-round-variables []\nfalse &gt; .new-round\nmax-timer &gt; .time-remaining) </code></pre> <p>Do not forget to add <code>reset-round-variables</code> to <code>initialize-round</code>! We need the variables to reset whenever a new round begins.</p> Code <pre><code>(defshards initialize-round []\n(RandomInt :Max .total-images) &gt; .left-image-index\n(RandomInt :Max .total-images) &gt; .right-image-index\n(reset-round-variables))\n</code></pre> <p>When the game ends and a new one begins, we will reset the following values:</p> <ul> <li> <p>Variables that are reset at the start of each round</p> </li> <li> <p>Total score</p> </li> <li> <p>Round counter</p> </li> <li> <p>The Game Over state tracker</p> </li> </ul> <p>Create the <code>reset-game-variables</code> shard to implement this.</p> Code <pre><code>(defshards reset-game-variables []\n(reset-round-variables)\n0 &gt; .total-score\n1 &gt; .current-round\nfalse &gt; .game-over)\n</code></pre> <p>You now have variables to track the game state and shards to reset these variables.</p> <p>We want to reset these values at the end of each round or game.</p>"},{"location":"yes-no-game/steps/step-4/#ending-a-round","title":"Ending a Round","text":"<p>Let us now create a Looped Wire named <code>end-round</code> to handle the end of each round.</p> <p>The Loop will first check if the current round is final. If it is, it sets the <code>.game-over</code> variable to true. Otherwise, it sets <code>.new-round</code> to true and increments the current round number.</p> Why a Looped Wire? <p>When a Wire ends, any changes made within it are lost. We use a Looped Wire when we want changes within the Wire to persist. </p> <p>For example, in <code>end-round</code>, we use <code>Setup</code> to initialize the variable <code>.new-round-number</code> once. With a Looped Wire, the variable continues to exist as long as the Looped Wire remains running. If we use a Wire, every time <code>.end-round</code> is called, <code>.new-round-number</code> will have to be initialized again.</p> <p>You might wonder - how do we exit the Loop after calling it then? Won't the program be stuck in the Loop indefinitely? The solution to this is in the shard called <code>Step</code> which we will introduce in the following chapter. If you wish to read more about <code>Step</code> and Looped Wires first, do check out our primer here.</p> Code <pre><code>(defloop end-round\n(Setup 0 &gt;= .new-round-number) ;; (1)\n\n.current-round (Math.Add 1) ;; (2) \n&gt; .new-round-number\n\n(If\n:Predicate\n(-&gt; .new-round-number (IsMore total-rounds)) ;; (3)\n:Then (-&gt; true &gt; .game-over) ;; (4)\n:Else (-&gt;\n.new-round-number &gt; .current-round ;; (5) \ntrue &gt; .new-round))) ;; (6)\n</code></pre> <ol> <li>Variable to hold the next round's number.</li> <li>Increment the current round by one to get the next round's number.</li> <li>Check if the next round's number exceeds the max number of rounds.</li> <li>If it has exceeded, set the .game-over variable to true.</li> <li>Otherwise set the new round number...</li> <li>... and set the .new-round variable to true.</li> </ol> <p>To end a round, the user has to give an answer or wait for the timer to expire. We will learn to work with user input in the next chapter.</p> <p> </p>"},{"location":"yes-no-game/steps/step-5/","title":"Step 5","text":"<p>For our game to engage and interact with users, we need it to be responsive to user input. </p> <p>In this chapter, we will be looking at how user input is handled in Shards.</p>"},{"location":"yes-no-game/steps/step-5/#user-input","title":"User Input","text":"<p>User input is managed within the <code>GFX.Window</code> of your game. For this game, the only user input required would be the \u2191 and \u2193 directional key.</p> <p>We can use <code>Inputs.KeyDown</code> to execute code whenever the user presses down on a specified key.</p> Code <pre><code>(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n...\n(GFX.Render :Steps .render-steps)\n\n(Inputs.KeyDown ;; (3)\n:Key \"up\"\n:Action ()) ;; (1) \n\n(Inputs.KeyDown\n:Key \"down\"\n:Action ())))) ;; (2) \n</code></pre> <ol> <li>This code is executed when the user presses the \u2191 directional key.</li> <li>This code is executed when the user presses the \u2193 directional key.</li> <li><code>Inputs.KeyDown</code> will run the code in its <code>Action</code> parameter when the <code>Key</code> specified is pressed down by the user.</li> </ol> <p>In order to prevent code within the <code>Inputs.Keydown</code> shards from executing whenever the user presses the specified key, we define a variable <code>.input-received</code> to track if we have already received the user's input.</p> <p>Define the variable in <code>initialize-variables</code> and add code to reset it in <code>reset-round-variables</code>.</p> Code <pre><code>(defshards initialize-variables []\n;; Variables to reset each round \ntrue &gt;= .new-round\nmax-timer &gt;= .time-remaining\nfalse &gt;= .input-received ;; (1) \n...)\n\n(defshards reset-round-variables []\nfalse &gt; .new-round\nmax-timer &gt; .time-remaining\nfalse &gt; .input-received) ;; (2) \n</code></pre> <ol> <li>Variable that tracks if an input from the user has been received.</li> <li>Resets the variable tracking whether user input has been received for each round.</li> </ol> <p>Now that we are able to obtain the user's input, we can proceed to check if the user pressed the correct button. </p>"},{"location":"yes-no-game/steps/step-5/#checking-the-input","title":"Checking the Input","text":"<p>Based on the images chosen, we can determine whether the user needs to select the \u2191 or \u2193 directional key. </p> <p>In <code>initialize-variables</code>, create a variable named <code>.same-image</code>. This will be used to check if the user pressed the correct key later.</p> Code <pre><code>(defshards initialize-variables []\n...\n\n;; Other Shared Variables\n0 &gt;= .left-image-index\n0 &gt;= .right-image-index\n(Count .images) &gt;= .total-images\ntrue &gt;= .same-image ;; (1) \n)\n</code></pre> <ol> <li>Tracks whether the same image is used.</li> </ol> <p>Navigate to where we chose the images in <code>initialize-round</code>. </p> <p>Check if the chosen images are the same, and assign <code>true</code> or <code>false</code> to <code>.same-image</code> accordingly.</p> Code <pre><code>(defshards initialize-round [] (RandomInt :Max .total-images) &gt; .left-image-index\n(RandomInt :Max .total-images) &gt; .right-image-index\n\n(If ;; (1)\n:Predicate (-&gt; .left-image-index (Is .right-image-index)) ;; (2)\n:Then (-&gt; true &gt; .same-image)\n:Else (-&gt; false &gt; .same-image))\n\n(reset-round-variables))\n</code></pre> <ol> <li><code>If</code> checks the <code>Predicate</code> given and runs the code within <code>Then</code> if it is true. If false, the code within <code>Else</code> is run instead.</li> <li>Check if the images on the left and right are the same or different.</li> </ol> <p>Create a shard named <code>check-answer</code> which will take in the user's input and check it against <code>.same-image</code>.</p> <p>The user is correct if they:</p> <ul> <li> <p>Pressed \u2191 when <code>.same-image</code> is true</p> </li> <li> <p>Pressed \u2193 when <code>.same-image</code> is false</p> </li> </ul> <p>We award them a point by increasing the value of <code>.total-score</code>.</p> <p>Set <code>.input-received</code> to true to prevent further user input, and end the round if <code>.game-over</code> is false.</p> Code <pre><code>(defshards check-answer [yes-input] ;; (1) \n(When\n:Predicate (-&gt; .input-received (Is false)) ;; (2)\n:Action\n(-&gt;\n(When\n:Predicate (-&gt; .same-image (Is yes-input)) ;; (3)\n:Action (-&gt; (Math.Inc .total-score))) ;; (4)\n\ntrue &gt; .input-received ;; (5) \n(When\n:Predicate (-&gt; .game-over (IsNot true)) ;; (6)\n:Action (-&gt; nil (Step end-round)))))) ;; (7)(8)(9)\n</code></pre> <ol> <li>Take in the user's input.</li> <li>Check if a user input has already been received.</li> <li>If the user pressed the \u2191 directional key when the same images are being shown...</li> <li>... increase the user's total score.</li> <li>Prevents this segment of code from running again until it is reset.</li> <li>If it is not Game Over yet...</li> <li>... end the round.</li> <li><code>Step</code> runs a wire inline.</li> <li><code>nil</code> ensures that any previous input (e.g. Bool from <code>true &gt; .input-received</code>) is not propagated into the wire. The first use of a wire defines its input type, and subsequent calls to the wire with different input types will be a violation.</li> </ol> Step vs Do <p>Step behaves similarly to <code>Do</code>, except that it allows you to use a Looped Wire like a function. <code>Step</code> will run one iteration of the Loop before returning control back to the Wire that called it. If you try to use <code>Do</code> on a Loop, the Loop will run indefinitely.</p> <p>Use a stepped Loop when you want a variable within the Loop to persist. When a Wire finishes, any changes made to the variables within it will be lost. A Looped Wire lives on, thereby retaining any changes within it. </p> <p>Check out the primer here for more information.</p> <p>We can now employ the <code>check-answer</code> shard in our <code>Inputs.KeyDown</code> logic.</p> Code <pre><code>(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n...\n(GFX.Render :Steps .render-steps)\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt; (check-answer true))) ;; (1)\n\n(Inputs.KeyDown\n:Key \"down\"\n:Action (-&gt; (check-answer false)))))) ;; (2)\n</code></pre> <ol> <li>Check-answer is called, with true being passed in to indicate that the user chose \"Yes\".</li> <li>Check-answer is called, with false being passed in to indicate that the user chose \"No\".</li> </ol> <p>Cheers! Your game can now receive user input, tabulate the score, and allows players to play up to 10 rounds each time.</p> Full CodeResult <pre><code>(def total-rounds 10)\n(def max-timer 5)\n\n(defshards load-resources []\n(LoadImage \"data/cats/cat01.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat02.png\") (Push :Name .images)\n(LoadImage \"data/cats/cat03.png\") (Push :Name .images))\n\n\n(defshards initialize-variables []\n;; Variables to reset each round \ntrue &gt;= .new-round\nmax-timer &gt;= .time-remaining\nfalse &gt;= .input-received\n\n;; Variables to reset each game \n0 &gt;= .total-score\n1 &gt;= .current-round\nfalse &gt;= .game-over\n\n;; Other Shared Variables\n0 &gt;= .left-image-index\n0 &gt;= .right-image-index\n(Count .images) &gt;= .total-images\ntrue &gt;= .same-image)\n\n(defshards reset-round-variables []\nfalse &gt; .new-round\nmax-timer &gt; .time-remaining\nfalse &gt; .input-received)\n\n(defshards reset-game-variables []\n(reset-round-variables)\n0 &gt; .total-score\n1 &gt; .current-round\nfalse &gt; .game-over)\n\n(defshards initialize-round []\n.total-images\n(RandomInt :Max .total-images) &gt; .left-image-index\n(RandomInt :Max .total-images) &gt; .right-image-index\n\n(If\n:Predicate (-&gt; .left-image-index (Is .right-image-index))\n:Then (-&gt; true &gt; .same-image)\n:Else (-&gt; false &gt; .same-image))\n\n(reset-round-variables))\n\n(defloop end-round\n(Setup 0 &gt;= .new-round-number)\n\n.current-round (Math.Add 1)\n&gt; .new-round-number\n\n(If\n:Predicate\n(-&gt; .new-round-number (IsMore total-rounds))\n:Then\n(-&gt; true &gt; .game-over)\n:Else\n(-&gt;\n.new-round-number &gt; .current-round\ntrue &gt; .new-round)))\n\n(defshards check-answer [yes-input]\n(When\n:Predicate (-&gt; .input-received (Is false))\n:Action\n(-&gt;\n(When\n:Predicate (-&gt; .same-image (Is yes-input))\n:Action (-&gt; (Math.Inc .total-score)))\n\ntrue &gt; .input-received\n(When\n:Predicate (-&gt; .game-over (IsNot true))\n:Action (-&gt; nil (Step end-round))))))\n\n\n(defshards main-game-ui []\n(UI.BottomPanel\n:Contents (-&gt; \"Are they the same image? Press the UP arrow if YES, and the DOWN arrow if NO.\" (UI.Label)))\n\n(UI.TopPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Score: \" (UI.Label)\n.total-score (ToString) (UI.Label)\n(UI.Separator)\n\"Round: \" (UI.Label)\n.current-round (ToString) (UI.Label)\n(UI.Separator)\n\"Time Left: \" (UI.Label)\n.time-remaining (ToString) (UI.Label)))))\n\n(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Horizontal\n:Contents\n(-&gt;\n(UI.Area\n:Position (float2 -250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take .left-image-index) (UI.Image)))\n(UI.Area\n:Position (float2 250.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt; .images (Take .right-image-index) (UI.Image))))))))\n\n(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n:Width 1280 :Height 768\n:Contents\n(-&gt;\n(Setup\n(GFX.DrawQueue) &gt;= .ui-draw-queue\n(GFX.UIPass .ui-draw-queue) &gt;&gt; .render-steps)\n(| .ui-draw-queue (GFX.ClearQueue))\n(UI .ui-draw-queue (main-game-ui))\n(GFX.Render :Steps .render-steps)\n\n(Inputs.KeyDown\n:Key \"up\"\n:Action (-&gt; (check-answer true)))\n\n(Inputs.KeyDown\n:Key \"down\"\n:Action (-&gt; (check-answer false))))))\n\n(defloop logic-loop\n(WhenNot\n:Predicate (-&gt; .game-over)\n:Action\n(-&gt;\n(When ;; \n:Predicate (-&gt; .new-round)\n:Action (-&gt; (initialize-round))))))\n\n\n(defshards initialize-round []\n.total-images\n(RandomInt :Max .total-images) &gt; .left-image-index (Log \"left\")\n(RandomInt :Max .total-images) &gt; .right-image-index (Log \"right\")\n\n; Determine if the images on the left and right are the same or different\n(If\n:Predicate (-&gt; .left-image-index (Is .right-image-index))\n:Then (-&gt; true &gt; .same-image)\n:Else (-&gt; false &gt; .same-image))\n\n(reset-round-variables))\n\n(defloop game-loop\n(Setup (load-resources) (initialize-variables))\n(Branch [ui-loop, logic-loop]))\n\n(defmesh main)\n(schedule main game-loop)\n(run main (/ 1.0 60.0))\n</code></pre> <p></p> <p> </p>"},{"location":"yes-no-game/steps/step-6/","title":"Step 6","text":"<p>Let us round up this tutorial by adding in the UI for the Game Over state and adding a Timer for extra challenge.</p> <p>We will be using a <code>UI.Button</code> to help us handle the user input for restarting the game.</p>"},{"location":"yes-no-game/steps/step-6/#game-over","title":"Game Over","text":"Code <pre><code>(defshards game-over-ui []\n(UI.CentralPanel\n:Contents\n(-&gt;\n(UI.Area\n:Position (float2 0.0, 0.0)\n:Anchor Anchor.Center\n:Contents\n(-&gt;\n\"GAME OVER\" (UI.Label)\n(UI.Horizontal\n:Contents\n(-&gt;\n\"Final Score: \" (UI.Label)\n.total-score (ToString) (UI.Label)\n\"/\"  (UI.Label)\ntotal-rounds (ToString) (UI.Label)))\n\n(UI.Button ;; (1)\n:Label \"Play Again!\"\n:Action (-&gt; (reset-game-variables))))))))\n</code></pre> <ol> <li><code>UI.Button</code> is a UI element that appears as a clickable button with the text passed into its <code>Label</code> parameter displayed on it.</li> </ol> <p>When the button is pressed, we reset the game's variables, including <code>.game-over</code> which will be used to decide what is drawn in our game's window.</p> <p>Navigate to <code>ui-loop</code> and add in <code>.game-over</code> conditionals.</p> BeforeAfter <pre><code>(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n...\n(| .ui-draw-queue (GFX.ClearQueue))\n(UI .ui-draw-queue (main-game-ui))\n(GFX.Render :Steps .render-steps))\n...\n</code></pre> <pre><code>(defloop ui-loop\n(GFX.MainWindow\n:Title \"Yes-No Game\"\n...\n(| .ui-draw-queue (GFX.ClearQueue))\n\n(If\n:Predicate (-&gt; .game-over)\n:Then (-&gt; (UI .ui-draw-queue (game-over-ui))) ;; (1)\n:Else (-&gt; (UI .ui-draw-queue (main-game-ui)))) ;; (2)\n\n(GFX.Render :Steps .render-steps)\n...\n</code></pre> <ol> <li>Draw the Game Over UI if .game-over is true.</li> <li>Draw the Main Game UI if .game-over is false.</li> </ol> <p>The game will now display the main game area or a game over screen depending on whether <code>.game-over</code> is true.</p>"},{"location":"yes-no-game/steps/step-6/#implementing-a-timer","title":"Implementing a Timer","text":"<p>To add additional challenge to the game (for additional fun!), we can impose a time limit on each round.</p> <p>Let us write a shard that decreases the <code>.time-remaining</code> every time it is called. </p> Code <pre><code>(defshards timer-tick []\n(When\n:Predicate (-&gt; .game-over (Is false)) ;; (1)\n:Action\n(-&gt;\n(Math.Dec .time-remaining) ;; (2)\n(When\n:Predicate (-&gt; .time-remaining (IsLess 0)) ;; (3)\n:Action (-&gt; nil (Step end-round))))))\n</code></pre> <ol> <li>When the game is still running...</li> <li>... decrease the time remaining by 1.</li> <li>The round is forced to end if the time remaining falls below 0.</li> </ol> <p>We can have <code>timer-tick</code> called every second consistently by using the <code>Once</code> shard. </p> <p>Place it within the <code>logic-loop</code> where we are checking if a new round should be started.</p> Code <pre><code>(defloop logic-loop\n(Once ;; (1)(2)\n:Action (-&gt; (timer-tick))\n:Every 1.0)\n\n(WhenNot\n:Predicate (-&gt; .game-over)\n:Action\n(-&gt;\n(When\n:Predicate (-&gt; .new-round)\n:Action (-&gt; (initialize-round))))))\n</code></pre> <ol> <li>Runs the timer-tick shard every 1 second.</li> <li><code>Once</code> will run the code in its <code>Action</code> parameter every time the duration specified in its <code>Every</code> parameter has passed.</li> </ol> <p>Note</p> <p>You can adjust the difficulty by changing the value of the <code>max-timer</code> constant we defined at the start.</p>"},{"location":"yes-no-game/steps/step-6/#outcome","title":"Outcome","text":"<p>Congratulations on making it to the end!</p> <p>Your game now has 10 rounds, calculates the total score, shows a Game Over screen and lets you play it again at the end. It even has a timer to add a time constraint to each round.</p> <p></p> <p></p> <p>Now that the tutorial is over, why not challenge yourself further by implementing a high-score system? You could also try adding support for a second player! </p> <p>The possibilities are endless with the power of Shards in your hands.</p> <p>The full game script can be found here.</p> <p> </p>"}]}